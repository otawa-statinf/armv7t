//
//	ARMv7 Thumb2 added instructions
//
//	This file is part of OTAWA
//	Copyright (c) 2011-12, IRIT UPS.
//
//	OTAWA is free software; you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//
//	OTAWA is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with OTAWA; if not, write to the Free Software
//	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//


// thumb-32 temporaries
var I1[1, card(1)]
var I2[1, card(1)]
var next_instr_addr[1, card(32)]


// Thumb-2 tree root
op thumb2 = thumb2_32
	/*| thumb2_16*/
	/*| fp add it when range will be supported in parameters */



// ****** thumb-32 32-bits ******
op thumb2_32(x: thumb2_32_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 4;
		PC = PC + 8;
		x.action;
		PC = NPC;
	}

op thumb2_32_list =
	  EOR_immediate_T1
	| BL_thumb
	| B_T3
	//| CLREX_T1
	| LDREX_T1
	| BLX_T2
	| mem_thumb2
	| ADD_register_T3
	| LSL_T2
	| MUL_T2


op CLREX_T1()
	image = "11110 0 111 01 1 1111  10 0 0 1111 0010 11111"
	syntax = "clrex"
	action = {
		// TODO
	}

op LSL_T2(rd: REG_INDEX, rn: REG_INDEX, rm: REG_INDEX, S: setS)
	image  = format("11111 010 0 00 %s %s 1111 %s 0 000 %s", S, rn, rd, rm)
	syntax = format("lsl%s.w %s, %s, %s", S, rd, rn, rm)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		m = UInt(rm);
		setflags = (S == 1);
		//if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;		
		//if ConditionPassed() then
			//EncodingSpecificOperations();
			//Shift_C(R[n], SRType_LSL, m, ASPR_C, result, carry) // TODO! Make this work.
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result); 
				APSR_C = carry;
				// APSR.V unchanged
			endif;
		//endif;
	}


op LDREX_T1 (rn: REG_INDEX, rt: REG_INDEX, imm8: card(8))
	image = format("11101 00 0 0 1 0 1 %s %s 1111 %8b", rn, rt, imm8)
	syntax = format("ldrex %s, [%s, #%d]", rt, rn, imm8)
	action = {
		// TODO
	}

op BLX_T2(s: card(1), imm10h: card(10), j1: card(1), j2: card(2), imm10l: card(10), h: card(1))
	imm32 = SignExtend(s :: (j1 ^ s) :: (j2 ^ s) :: imm10h :: imm10l :: 0<1..0>, 7)
	target = Align(__IADDR, 4) + imm32
	targetAddress = Align(PC, 4) + imm32

	image  = format("11110 %1b %10b 11 %1b 0 %1b %10b %1b", s, imm10h, j1, j2, imm10l, h)
	syntax = format("blx %l", target)
	action = {
		// if CurrentInstrSet() == InstrSet_ThumbEE || H == '1' then UNDEFINED;
		// if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
		// 		EncodingSpecificOperations();
		if CurrentInstrSet() == InstrSet_ARM then
			LR = PC;				 	// in ARM ref, PC + 4
		else
			LR = (PC<31..1> + 4) :: 1;	// in ARM ref, PC<31..1> :: 1
		endif;
		SelectInstrSet(InstrSet_ARM);
		BranchWritePC_thumb(targetAddress);
	}


// BL from Thumb2 (is equivalent to two successive Thumb1 16-bits BL)
// In Thumb32, the 16-bits lonely version is now forbidden.
op BL_thumb(J1: card(1), J2: card(1), S: card(1), imm10: card(10), imm11: card(11))
	addr = __IADDR + 4 + coerce(int(32), S :: ~(J1 ^ S) :: ~(J2 ^ S) :: imm10 :: imm11 :: 0<0..0>)
	syntax = format("bl %08x", addr)
	image = format("11110 %1b %10b 11 %1b 1 %1b %11b", S, imm10, J1, J2, imm11)
	action = {
		// if ConditionPassed then
			// targetInstrSet = CurrentInstrSet();
			// if InITBlock() && !LastInITBlock() then UNPREDICTABLE; endif;
			next_instr_addr = PC;
			LR = next_instr_addr<31..1> :: 1<0..0>;
			BranchWritePC_thumb(addr); 
		// endif
	}

op EOR_immediate_T1(i: card(1), S: setS, rd: REG_INDEX, rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> TEQ (immediate)
	syntax = format("eor%s %s, %s, #%08x", S, rd, rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0100 %s %s 0 %3b %s %8b", i, S, rn, imm3, rd, imm8)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		setflags = (S == 1);
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
		// if d == 13 || (d == 15 && S == 0) || n >= 13 then UNPREDICTABLE;
		// if ConditionPassed() then
		//	EncodingSpecificOperations();
		result = R[n] ^ imm32;
		if d == 15 then
			ALUWritePC(result); // setflags is always FALSE here
		else
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = carry;
			endif;
		endif;
	}

op ADD_register_T3(S: bool, Rd: REG_INDEX, Rn: REG_INDEX, shift: ShiftOperand)
	syntax = format("add%s.w %s, %s, %s", if S then ".s" else "" endif, Rd.syntax, Rn.syntax, shift.syntax) 
	image = format("11101 01 1000 %1b %4b 0 %3b %4b %2b %2b %4b", S, shift.Rm, shift.n<4..2>, Rd.image, shift.n<1..0>, shift.t, Rn.image)
	action = {
		// if Rd == '1111' && S == '1' then SEE CMN (register);
		// if Rn == '1101' then SEE ADD (SP plus register);
		d = UInt(Rd);
		//n = UInt(Rn);
		m = UInt(shift.Rm);
		setflags = (S == 1);
		// (shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
		// if d == 13 || (d == 15 && S == 0) || n == 15 || m >= 13 then UNPREDICTABLE;
		shifted = shift;
		AddWithCarry(result, carry, overflow, R[Rn], shifted, 0);
		if d == 15 then
			ALUWritePC(result);
		else
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = carry;
				APSR_V = overflow;
			endif;
		endif;			
	}


op MUL_T2(Rd: REG_INDEX, Rn: REG_INDEX, Rm: REG_INDEX)
	syntax = format("mul %s, %s, %s", Rd, Rn, Rm)
	image = format("11111 0110 000 %s 1111 %s 0000 %s", Rn, Rd, Rm)
	action = {
		d = UInt(Rd);
		n = UInt(Rn);
		m = UInt(Rm);
		setflags = 0;
		// if d >= 13 || n >= 13 || m >= 13 then UNPREDICTABLE;
		operand1 = SInt(R[n]); 		// operand1 = UInt(R[n]) produces the same final results
		operand2 = SInt(R[m]); 		// operand2 = UInt(R[m]) produces the same final results
		result = operand1 * operand2;
		R[d] = result<31..0>;
		if setflags then
			APSR_N = result<31..31>;
			APSR_Z = IsZeroBit(result<31..0>);
			// if ArchVersion() == 4 then
			//		APSR_C = bit UNKNOWN;
			// else APSR.C unchanged
			// APSR.V always unchanged
		endif;		
	}

op B_T3(S: card(1), cond: condition, imm6: card(6), J1: card(1), J2: card(2), imm11: card(11))
	imm32 = SignExtend(S :: J2 :: J1 :: imm6 :: imm11 :: 0b0, 11)
	target = __IADDR + imm32 + 8
	syntax = format("b%s.w %l", cond, target)
	image = format("11110 %1b %s %6b 10 %1b 0 %1b %11b", S, cond, imm6, J1, J2, imm11)
	action = {
		// if cond<3:1> == '111' then SEE "Related encodings";
		// if InITBlock() then UNPREDICTABLE;
		if ConditionPassed() then
			BranchWritePC(PC + imm32);
		endif;
	}
	  

// ****** thumb-2 16-bits ******

/*op thumb2_16(x: thumb2_16_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 2;
		PC = PC + 2;
		x.action;
		PC = NPC;
	}

op thumb2_16_list = CLREX_T1*/
