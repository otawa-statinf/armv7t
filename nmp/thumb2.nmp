//
//	ARMv7 Thumb2 added instructions
//
//	This file is part of OTAWA
//	Copyright (c) 2011-12, IRIT UPS.
//
//	OTAWA is free software; you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//
//	OTAWA is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with OTAWA; if not, write to the Free Software
//	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//


// thumb-32 temporaries
var I1[1, card(1)]
var I2[1, card(1)]
var next_instr_addr[1, card(32)]


// Thumb-2 tree root
op thumb2 = thumb2_32
	/*| thumb2_16*/
	| fp /* add it when range will be supported in parameters */



// ****** thumb-32 32-bits ******
op thumb2_32(x: thumb2_32_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 4;
		PC = PC + 8;
		x.action;
		PC = NPC;
	}

op thumb2_32_list = AND_immediate_T1
	| EOR_immediate_T1
	| BL_immediate_T1
	| B_T3
	| B_T4
	| TBB_TBH
	| ADD_register_T3
	| ADD_immediate_T3
	| SUB_immediate
	| BIC_immediate_T1
	| CLZ_T1
	//| CLREX_T1
	| LDREX_T1
	| BLX_immediate_T2
	| mem_thumb2
	| LSL_register_T2
	| MUL_T2
	| MOV_immediate
	| MOVT_T1
	| BFIC_T1


op CLREX_T1()
	image = "11110 0 111 01 1 1111  10 0 0 1111 0010 11111"
	syntax = "clrex"
	action = {
		// TODO
		//if ConditionPassed() then 
			//EncodingSpecificOperations(); 
			//ClearExclusiveLocal(ProcessorID());
	}

op LSL_register_T2(rd: REG_INDEX, rn: REG_INDEX, rm: REG_INDEX, S: setS)
	image  = format("11111 010 0 00 %s %s 1111 %s 0 000 %s", S, rn, rd, rm)
	syntax = format("lsl%s.w %s, %s, %s", S, rd, rn, rm)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		m = UInt(rm);
		setflags = (S == 1);
		//if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;		
		//if ConditionPassed() then
			//EncodingSpecificOperations();
			//Shift_C(R[n], SRType_LSL, m, ASPR_C, result, carry) // TODO! Make this work.
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result); 
				APSR_C = carry;
				// APSR.V unchanged
			endif;
		//endif;
	}


op LDREX_T1 (rn: REG_INDEX, rt: REG_INDEX, imm8: card(8))
	image = format("11101 00 0 0 1 0 1 %s %s 1111 %8b", rn, rt, imm8)
	syntax = format("ldrex %s, [%s, #%d]", rt, rn, imm8)
	action = {
		// TODO
	}

op BLX_immediate_T2(S: card(1), imm10H: card(10), J1: card(1), J2: card(1), imm10L: card(10), H: card(1))
	// if CurrentInstrSet() == InstrSet_ThumbEE || H == '1' then UNDEFINED;
	// if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
	imm32 = SignExtend(S :: ~(J1 ^ S) :: ~(J2 ^ S) :: imm10H :: imm10L :: 0b00, 7)
	targetAddress = Align(__IADDR, 4) + 4 + imm32 // in ARM ref, targetAddress = PC + imm32;
	image  = format("11110 %1b %10b 11 %1b 0 %1b %10b %1b", S, imm10H, J1, J2, imm10L, H)
	syntax = format("blx 0x%08x", targetAddress)
	action = {
		LR = (__IADDR<31..1> :: 0b1) + 4;	// in ARM ref, PC<31:1> : '1';
		SelectInstrSet(InstrSet_ARM);
		BranchWritePC_thumb(targetAddress);
	}


// BL from Thumb2 (is equivalent to two successive Thumb1 16-bits BL)
// In Thumb32, the 16-bits lonely version is now forbidden.
op BL_immediate_T1(J1: card(1), J2: card(1), S: card(1), imm10: card(10), imm11: card(11))
	addr = __IADDR + 4 + coerce(int(32), S :: ~(J1 ^ S) :: ~(J2 ^ S) :: imm10 :: imm11 :: 0<0..0>)
	syntax = format("bl 0x%08x", addr)
	image = format("11110 %1b %10b 11 %1b 1 %1b %11b", S, imm10, J1, J2, imm11)
	action = {
		// if ConditionPassed then
			// targetInstrSet = CurrentInstrSet();
			// if InITBlock() && !LastInITBlock() then UNPREDICTABLE; endif;
			next_instr_addr = PC;
			LR = next_instr_addr<31..1> :: 1<0..0>;
			BranchWritePC_thumb(addr); 
		// endif
	}
	
op AND_immediate_T1(i: card(1), S: setS, Rn: REG_INDEX, imm3: card(3), Rd: REG_INDEX, imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> TST (immediate)
	syntax = format("and%s %s, %s, #0x%08x", S, Rd, Rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0000 %s %s  0 %3b %s %8b", i, S, Rn, imm3, Rd, imm8)
	d = UInt(Rd)
	n = UInt(Rn)
	setflags = S
	//if d == 13 || (d == 15 && S == '0') || n IN {13,15} then UNPREDICTABLE;
	action = {
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
		//if ConditionPassed() then
			//EncodingSpecificOperations();
			result = R[n] & imm32;
			if d == 15 then // Can only occur for ARM encoding
				ALUWritePC(result); // setflags is always FALSE here 
			else
				R[d] = result; 
				if setflags then
					APSR_N = result<31..31>;
					APSR_Z = IsZeroBit(result); 
					APSR_C = carry;
					// APSR.V unchanged
				endif;
			endif;
	}

op EOR_immediate_T1(i: card(1), S: setS, rd: REG_INDEX, rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> TEQ (immediate)
	syntax = format("eor%s %s, %s, #0x%08x", S, rd, rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0100 %s %s 0 %3b %s %8b", i, S, rn, imm3, rd, imm8)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		setflags = (S == 1);
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
		// if d == 13 || (d == 15 && S == 0) || n >= 13 then UNPREDICTABLE;
		// if ConditionPassed() then
		//	EncodingSpecificOperations();
		result = R[n] ^ imm32;
		if d == 15 then
			ALUWritePC(result); // setflags is always FALSE here
		else
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = carry;
			endif;
		endif;
	}
	
op ADD_immediate_T3(i: card(1), S: setS, rd: REG_INDEX, rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> CMN (immediate)
	//	rn = 0b1101 -> ADD (SP plus immediate)
	syntax = format("add%s.w %s, %s, #0x%08x", S, rd, rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 1000 %s %s 0 %3b %s %8b", i, S, rn, imm3, rd, imm8)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		setflags = (S == 1);
		imm32 = ThumbExpandImm(i :: imm3 :: imm8);
		// if d == 13 || (d == 15 && S == 0) || n == 15 then UNPREDICTABLE;
		// if ConditionPassed() then
		//	EncodingSpecificOperations();
		AddWithCarry(result, carry, overflow, R[n], imm32, 0);
		R[d] = result;
		if setflags then
			APSR_N = result<31..31>;
			APSR_Z = IsZeroBit(result);
			APSR_C = carry;
			APSR_V = overflow;
		endif;
	}

op ADD_register_T3(S: bool, Rd: REG_INDEX, Rn: REG_INDEX, shift: ShiftOperand)
	syntax = format("add%s.w %s, %s, %s", if S then ".s" else "" endif, Rd.syntax, Rn.syntax, shift.syntax) 
	image = format("11101 01 1000 %1b %s  0 %3b %s %2b %2b %4b", S, Rn.image, shift.n<4..2>, Rd.image, shift.n<1..0>, shift.t, shift.Rm)
	action = {
		// if Rd == '1111' && S == '1' then SEE CMN (register);
		// if Rn == '1101' then SEE ADD (SP plus register);
		d = UInt(Rd);
		//n = UInt(Rn);
		m = UInt(shift.Rm);
		setflags = (S == 1);
		// (shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
		// if d == 13 || (d == 15 && S == 0) || n == 15 || m >= 13 then UNPREDICTABLE;
		shifted = shift;
		AddWithCarry(result, carry, overflow, R[Rn], shifted, 0);
		if d == 15 then
			ALUWritePC(result);
		else
			R[d] = result;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = carry;
				APSR_V = overflow;
			endif;
		endif;			
	}


op SUB_immediate(x: SUB_immediate_list)
	syntax = x.syntax
	image = x.image
	action = {
		//if ConditionPassed() then
			//EncodingSpecificOperations();
			AddWithCarry(result, carry, overflow, R[x.n], ~x.imm32, 1);
			R[x.d] = result;
			if x.setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = carry;
				APSR_V = overflow;
			endif;
	}

// should provide d, n, setflags, imm32
op SUB_immediate_list = SUB_immediate_T3 | SUB_immediate_T4

op SUB_immediate_T3(i: card(1), S: setS, Rd: REG_INDEX, Rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> CMP (immediate)
	//	rn = 0b1101 -> SUB (SP minus immediate)
	syntax = format("sub%s.w %s, %s, #%d", S, Rd, Rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 1101 %s %s  0 %3b %s %8b", i, S, Rn, imm3, Rd, imm8)
	d = UInt(Rd)
	n = UInt(Rn)
	setflags = S
	imm32 = ThumbExpandImm(i :: imm3 :: imm8)
	//if d == 13 || (d == 15 && S == '0') || n == 15 then UNPREDICTABLE;
	
op SUB_immediate_T4(i: card(1), Rd: REG_INDEX, Rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rn = 0b1111 -> ADR
	//	rn = 0b1101 -> SUB (SP minus immediate)
	syntax = format("subw %s, %s, #%d", Rd, Rn, ZeroExtend(i :: imm3 :: imm8, 32))
	image = format("11110 %1b 1 0101 0 %s  0 %3b %s %8b", i, Rn, imm3, Rd, imm8)
	d = UInt(Rd)
	n = UInt(Rn)
	setflags = 0
	imm32 = ZeroExtend(i :: imm3 :: imm8, 32)
	//if d IN {13,15} then UNPREDICTABLE;
		
op MUL_T2(Rd: REG_INDEX, Rn: REG_INDEX, Rm: REG_INDEX)
	syntax = format("mul %s, %s, %s", Rd, Rn, Rm)
	image = format("11111 0110 000 %s 1111 %s 0000 %s", Rn, Rd, Rm)
	action = {
		d = UInt(Rd);
		n = UInt(Rn);
		m = UInt(Rm);
		setflags = 0;
		// if d >= 13 || n >= 13 || m >= 13 then UNPREDICTABLE;
		operand1 = SInt(R[n]); 		// operand1 = UInt(R[n]) produces the same final results
		operand2 = SInt(R[m]); 		// operand2 = UInt(R[m]) produces the same final results
		result = operand1 * operand2;
		R[d] = result<31..0>;
		if setflags then
			APSR_N = result<31..31>;
			APSR_Z = IsZeroBit(result<31..0>);
			// if ArchVersion() == 4 then
			//		APSR_C = bit UNKNOWN;
			// else APSR.C unchanged
			// APSR.V always unchanged
		endif;		
	}
	
op BIC_immediate_T1(i: card(1), S: setS, Rn: REG_INDEX, imm3: card(3), Rd: REG_INDEX, imm8: card(8))
	syntax = format("bic%s %s, %s, #0x%03x", S, Rd, Rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0001 %s %s  0 %3b %s %8b", i, S, Rn, imm3, Rd, imm8)
	action = {
		d = UInt(Rd);
		n = UInt(Rn);
		setflags = (S == 1);
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
		//if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
		//if ConditionPassed() then
			//EncodingSpecificOperations();
			result = R[n] & ~imm32;
			if d == 15 then // Can only occur for ARM encoding
				ALUWritePC(result); // setflags is always FALSE here 
			else
				R[d] = result<31..0>; 
				if setflags then
					APSR_N = result<31..31>;
					APSR_Z = IsZeroBit(result<31..0>); 
					APSR_C = carry;
					// APSR.V unchanged
				endif;
			endif;
		//endif
	}

op CLZ_T1(Rd: REG_INDEX, Rm: REG_INDEX)
	syntax = format("clz %s, %s", Rd.syntax, Rm.syntax)
	image = format("11111 010 1 011 %s 1111 %s 1 000 %s", Rm.image, Rd.image, Rm.image)
	//if !Consistent(Rm) then UNPREDICTABLE;
	//if Rd IN {13,15} || Rm IN {13,15} then UNPREDICTABLE;
	action = {
		// EncodingSpecificOperations();
		TMP_BYTE = 32;
		TMP_SWORD = GPR[Rm];
		most_sign_bit;
		GPR[Rd] = 31 - TMP_INC;
	}

	most_sign_bit = {	
		if (TMP_BYTE != 0) then       	       
			if (TMP_SWORD & 0x80000000 == 1) then
				TMP_INC = TMP_BYTE-1;			
			else
				TMP_SWORD = TMP_SWORD << 1;
				//Decrease the register counter
				TMP_BYTE = TMP_BYTE - 1;
				most_sign_bit;
			endif;
		endif;
	}

op B_T3(S: card(1), cond: condition, imm6: card(6), J1: card(1), J2: card(1), imm11: card(11))
	imm32 = SignExtend(S :: J2 :: J1 :: imm6 :: imm11 :: 0b0, 11)
	target = __IADDR + imm32 + 4
	syntax =
		if cond.value<3..1> == 0b111
		then "nop.w"
		else format("b%s.w %l", cond, target) endif
	image = format("11110 %1b %s %6b 10 %1b 0 %1b %11b", S, cond, imm6, J1, J2, imm11)
	action = {
		// if cond<3:1> == '111' then SEE "Related encodings";
		// if InITBlock() then UNPREDICTABLE;
		if cond.value<3..1> == 0b111 then
			// do nothing
		else
			if ConditionPassed() then
				BranchWritePC(PC + imm32);
			endif;
		endif;
	}
	  

op B_T4(S: card(1), imm10: card(10), J1: card(1), J2: card(1), imm11: card(11))
	imm32 = SignExtend(S :: J1 :: J2 :: imm10 :: imm11 :: 0b0, 7)
	target = __IADDR + imm32 + 4
	syntax = format("b.w %l", target)
	image = format("11110 %1b %10b 10 %1b 1 %1b %11b", S, imm10, J1, J2, imm11)
	action = {
		// if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
		//if ConditionPassed() then
			BranchWritePC(PC + imm32);
		//endif;
	}
	  
op TBB_TBH(Rn: REG_INDEX, Rm: REG_INDEX, H:card(1))
	syntax = 
		if H  then format("tbh [%s, %s, lsl #1]", Rn, Rm) 
		else format("tbb [%s, %s]", Rn, Rm) endif
	image = format("11101 00 0 1 1 0 1 %s 1111 0000 000 %1b %s", Rn, H, Rm)
	action = {
		n = UInt(Rn);
		m = UInt(Rm);
		//if n == 13 || m IN {13,15} then UNPREDICTABLE;
		// TODO!
		// Table Branch Byte causes a PC-relative forward branch using a table of single byte offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value of the byte returned from the table.
		// Table Branch Halfword causes a PC-relative forward branch using a table of single halfword offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value of the halfword returned from the table.
	}

op MOV_immediate(x: mov_immediate_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations();
			init_imm32_carry;
			result = imm32;
			if x.d == 15 then // Can only occur for encoding A1
				ALUWritePC(result); // setflags is always FALSE here 
			else
				R[x.d] = result; 
				if x.setflags then
					APSR_N = result<31..31>;
					APSR_Z = IsZeroBit(result); 
					APSR_C = carry;
					// APSR.V unchanged
				endif;
			endif;
		endif;
	}
	
// should provide d, setflags, condition, init_imm32_carry
op mov_immediate_list = MOV_immediate_T2 | MOV_immediate_T3

op MOV_immediate_T2(i: card(1), S: setS, Rd: REG_INDEX, imm3: card(3), imm8: card(8))
	syntax = format("mov%s.w %s, #%d", S, Rd, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0010 %s 1111  0 %3b %s %8b", i, S, imm3, Rd, imm8)
	d = UInt(Rd)
	setflags = S 
	condition = 1
	init_imm32_carry = {
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
	}
	//if d IN {13,15} then UNPREDICTABLE;

op MOV_immediate_T3(i: card(1), Rd: REG_INDEX, imm3: card(3), imm4: card(4), imm8: card(8))
	syntax = format("movw %s, #%d", Rd, ZeroExtend(imm4 :: i :: imm3 :: imm8, 16))
	image = format("11110 %1b 10 0 1 0 0 %4b  0 %3b %s %8b", i, imm4, imm3, Rd, imm8)
	d = UInt(Rd)
	setflags = 0
	condition = 1
	init_imm32_carry = {
		imm32 = ZeroExtend(imm4 :: i :: imm3 :: imm8, 16);
	}
	//if d IN {13,15} then UNPREDICTABLE;
	
op MOVT_T1(i: card(1), Rd: REG_INDEX, imm3: card(3), imm4: card(4), imm8: card(8))
	syntax = format("movt %s, #%d", Rd, imm4 :: i :: imm3 :: imm8)
	image= format("11110 %1b 10 1 1 0 0 %4b  0 %3b %s %8b", i, imm4, imm3, Rd, imm8)
	d = UInt(Rd)
	//if d IN {13,15} then UNPREDICTABLE;
	action = {
		R[d]<31..16> = imm4 :: i :: imm3 :: imm8;
		// R[d]<15:0> unchanged
	}
	
op BFIC_T1(Rd: REG_INDEX, Rn: REG_INDEX, msb: card(5), imm3: card(3), imm2: card(2))
	syntax =
		if Rn.number == 0b1111
		then format("bfc %s, #%d, #%d", Rd, (imm3 :: imm2), msb - (imm3 :: imm2) + 1)
		else format("bfi %s, %s, #%d, #%d", Rd, Rn, (imm3 :: imm2), msb - (imm3 :: imm2) + 1)
		endif
	image = format("11110 0 11 011 0 %s  0 %3b %s %2b 0 %5b", Rn, imm3, Rd, imm2, msb)
	d = UInt(Rd)
	n = UInt(Rn)
	msbit = UInt(msb)
	lsbit = UInt(imm3 :: imm2)
	//if d IN {13,15} then UNPREDICTABLE;
	action = {
		if msbit >= lsbit then
			if Rn.number == 15 then
				R[Rd]<msbit..lsbit> = 0;
			else
				//if n == 13 then UNPREDICTABLE;
				R[Rd]<msbit..lsbit> = R[Rn]<(msbit-lsbit)..0>;
			endif;
		else
			error("UNPREDICTABLE");
		endif;
	}

	
			
// ****** thumb-2 16-bits ******

/*op thumb2_16(x: thumb2_16_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 2;
		PC = PC + 2;
		x.action;
		PC = NPC;
	}

op thumb2_16_list = CLREX_T1*/
