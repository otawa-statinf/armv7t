//
//	ARMv7 Thumb2 added instructions
//
//	This file is part of OTAWA
//	Copyright (c) 2011-12, IRIT UPS.
//
//	OTAWA is free software; you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//
//	OTAWA is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with OTAWA; if not, write to the Free Software
//	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//


// thumb-32 temporaries
var I1[1, card(1)]
var I2[1, card(1)]
var next_instr_addr[1, card(32)]
var result[1, card(32)]


// Thumb-2 tree root
op thumb2 = thumb2_32
	/*| thumb2_16*/
	/*| fp add it when range will be supported in parameters */



// ****** thumb-32 32-bits ******
op thumb2_32(x: thumb2_32_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 4;
		PC = PC + 4;
		x.action;
		PC = NPC;
	}

op thumb2_32_list =
	  EOR_immediate_T1
	| BL_thumb
	| CLREX_T1
	| LDREX_T1
	| BLX_T2
	| mem_thumb2


op CLREX_T1()
	image = "11110 0 111 01 1 1111  10 0 0 1111 0010 11111"
	syntax = "clrex"
	action = {
		// TODO
	}

op LDREX_T1 (rn: REG_INDEX, rt: REG_INDEX, imm8: card(8))
	image = format("11101 00 0 0 1 0 1 %s %s 1111 %8b", rn, rt, imm8)
	syntax = format("ldrex %s, [%s, #%d]", rt, rn, imm8)
	action = {
		// TODO
	}

op BLX_T2(s: card(1), imm10h: card(10), j1: card(1), j2: card(2), imm10l: card(10), h: card(1))
	imm32 = SignExtend(s :: (j1 ^ s) :: (j2 ^ s) :: imm10h :: imm10l :: 0<1..0>, 7)
	target = Align(__IADDR, 4) + imm32
	targetAddress = Align(PC, 4) + imm32

	image  = format("11110 %1b %10b 11 %1b 0 %1b %10b %1b", s, imm10h, j1, j2, imm10l, h)
	syntax = format("blx %l", target)
	action = {
		// if CurrentInstrSet() == InstrSet_ThumbEE || H == '1' then UNDEFINED;
		// if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
		// 		EncodingSpecificOperations();
		if CurrentInstrSet() == InstrSet_ARM then
			LR = PC;				 	// in ARM ref, PC + 4
		else
			LR = (PC<31..1> + 4) :: 1;	// in ARM ref, PC<31..1> :: 1
		endif;
		SelectInstrSet(InstrSet_ARM);
		BranchWritePC_thumb(targetAddress);
	}


// BL from Thumb2 (is equivalent to two successive Thumb1 16-bits BL)
// In Thumb32, the 16-bits lonely version is now forbidden.
op BL_thumb(J1: card(1), J2: card(1), S: card(1), imm10: card(10), imm11: card(11))
	addr = __IADDR + 4 + coerce(int(32), S :: ~(J1 ^ S) :: ~(J2 ^ S) :: imm10 :: imm11 :: 0<0..0>)
	syntax = format("bl %08x", addr)
	image = format("11110 %1b %10b 11 %1b 1 %1b %11b", S, imm10, J1, J2, imm11)
	action = {
		// if ConditionPassed then
			// targetInstrSet = CurrentInstrSet();
			// if InITBlock() && !LastInITBlock() then UNPREDICTABLE; endif;
			next_instr_addr = PC;
			LR = next_instr_addr<31..1> :: 1<0..0>;
			BranchWritePC_thumb(addr); 
		// endif
	}

op EOR_immediate_T1(i: card(1), S: setS, rd: REG_INDEX, rn: REG_INDEX, imm3: card(3), imm8: card(8))
	// range decoding
	//	rd = 0b1111 && S == 1 -> TEQ (immediate)
	syntax = format("eor%s %s, %s, #%08x", S, rd, rn, ThumbExpandImm(i :: imm3 :: imm8))
	image = format("11110 %1b 0 0100 %s %s 0 %3b %s %8b", i, S, rn, imm3, rd, imm8)
	action = {
		d = UInt(rd);
		n = UInt(rn);
		setflags = (S == 1);
		ThumbExpandImm_C(i :: imm3 :: imm8, imm32, carry);
		// if d == 13 || (d == 15 && S == 0) || n >= 13 then UNPREDICTABLE;
		// if ConditionPassed() then
		//	EncodingSpecificOperations();
		result = R[n] ^ imm32;
		if d == 15 then
			ALUWritePC(result); // setflags is always FALSE here
		else
			R[d] = result;
			if setflags then
				ASPR_N = result<31..31>;
				ASPR_Z = IsZeroBit(result);
				ASPR_C = carry;
			endif;
		endif;
	}


// ****** thumb-2 16-bits ******

/*op thumb2_16(x: thumb2_16_list)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 2;
		PC = PC + 2;
		x.action;
		PC = NPC;
	}

op thumb2_16_list = CLREX_T1*/
