
///////////////////////////////////
//B bit for Load/Store instruction
///////////////////////////////////


op setBon()
	syntax = "B"
	image = "1"
	action = {
		BBIT = 1;
	}

op setBoff()
	syntax = ""
	image = "0"
	action = {
		BBIT = 0;
	}



///////////////////////////////////////////
// Load/Store Instructions Multiple
///////////////////////////////////////////

op  Mem_load_store_multiple(cond: condition, adr_mode: u2, sets: u1, setw: u1, setl: u1, rn: REG_INDEX, reglist: REG_LIST)
	syntax = format("%sM%s%s %s%s, {%s}%s",
		if setl then 'LD' else 'ST' endif,
		cond.syntax,
		switch (adr_mode) {
			case 1: 'IA'
			case 3:	'IB'
			case 0:	'DA'
			case 2: 'DB'
		},
		rn.syntax,
		if setw then '!' else '' endif,
		reglist.syntax,
		if sets then '^' else '' endif)

	image = format("%s100%2b%1b%1b%1b%s%16b", cond.image, adr_mode,sets, setw, setl,rn.image, reglist) 

	action = {
		if (cond) then
			TMP_REGLIST = reglist;	  
			//Compute number of set bits in the register list to compute the start address
			TMP_BYTE  = 0;
			TMP_SETBIT = 0;
			B15SET = 0;
			number_of_set_bits_in;
			TMP_REG3 = Get_ARM_GPR(rn);		  
			TMP_START_ADDR = TMP_REG3;
			TMP_BYTE = 0;
			TMP_REGLIST = reglist;
			if adr_mode == 0 then  //DAMODE
				TMP_START_ADDR = TMP_START_ADDR-(4*TMP_SETBIT)+4;
				TMP_END_ADDR = TMP_START_ADDR;  			  
			endif;
			if adr_mode == 1 then  //IAMODE
				TMP_START_ADDR = TMP_START_ADDR; 
				TMP_END_ADDR = TMP_START_ADDR+4*TMP_SETBIT;	
			endif;
			if adr_mode == 2 then //DBMODE
				TMP_START_ADDR = TMP_START_ADDR-(4*TMP_SETBIT)-4;
				TMP_END_ADDR = TMP_START_ADDR+4;
			endif;
			if adr_mode == 3 then //IBMODE 
				TMP_START_ADDR = TMP_START_ADDR;
				TMP_END_ADDR = TMP_START_ADDR+4*TMP_SETBIT+4;
			endif;	
			if (setl == 0) then
				recurs_stm;
			else
				recurs_ldm;		
			endif;		  		  
			if (setw == 1) then
				Set_ARM_GPR(rn, TMP_END_ADDR);;
			endif;
		endif;

	}	       
	number_of_set_bits_in = {
			//Count the amount of bits into the list
			if (TMP_BYTE != 16) then
				if ((TMP_REGLIST & 1) == 1) then
					TMP_SETBIT = TMP_SETBIT + 1;
					if (TMP_BYTE == 15) then
						B15SET = 1;
					endif;		     
				endif;
				TMP_REGLIST = TMP_REGLIST >> 1;
				TMP_BYTE = TMP_BYTE + 1;
				number_of_set_bits_in;
			endif;
	}  

	recurs_stm = {
			//We will test all of the 16 bits of the register list
			//If a bit is set then we must add the value of the corresponding register
			//to the stack.
			if (TMP_BYTE != 16) then
				if ((TMP_REGLIST & 1) == 1) then
					if adr_mode == 0 then //DAMODE
						STMDA(TMP_BYTE, sets);
					endif;
					if adr_mode == 1 then //IAMODE
						STMIA(TMP_BYTE, sets);
					endif;
					if adr_mode == 2 then  //DBMODE
						STMDB(TMP_BYTE, sets);
					endif;
					if adr_mode == 3 then //IBMODE 
						STMIB(TMP_BYTE, sets);
					endif;
				endif;	
			else 		
				//Get the next bit
				TMP_REGLIST = TMP_REGLIST >> 1;
				//Increase the register counter
				TMP_BYTE = TMP_BYTE + 1;
				recurs_stm;
			endif;
	}

	recurs_ldm = {
			//We will test all of the 16 bits of the register list
			//If a bit is set then we must retrieve the value of the corresponding register
			//from the stack.
			if (TMP_BYTE != 16) then
				if (sets == 0) then
					if (TMP_BYTE != 15) then
						if ((TMP_REGLIST & 1) == 1) then
							if adr_mode == 0 then //DAMODE
								TMP_REG3 = GetGPRIndex(TMP_BYTE);
								LDMDA1(TMP_REG3);
							endif;
							if adr_mode == 1 then //IAMODE
								TMP_REG3 = GetGPRIndex(TMP_BYTE);
								LDMIA1(TMP_REG3);
							endif;
							if adr_mode == 2 then  //DBMODE
								TMP_REG3 = GetGPRIndex(TMP_BYTE);
								LDMDB1(TMP_REG3);
							endif;
							if adr_mode == 3 then //IBMODE
								TMP_REG3 = GetGPRIndex(TMP_BYTE);
								LDMIB1(TMP_REG3);
							endif;
						endif;
					else
						if ((TMP_REGLIST & 1) == 1) then
							if adr_mode == 0 then //DAMODE
								LDMDA1_NIA();
							endif;
							if adr_mode == 1 then //IAMODE
								LDMIA1_NIA();
							endif;
							if adr_mode == 2 then //DBMODE
								LDMDB1_NIA();
							endif;
							if adr_mode == 3 then //IBMODE
								LDMIB1_NIA();
							endif;
						endif;
					endif;						
				else
					if (B15SET == 0) then	
						if (TMP_BYTE != 15) then
							if ((TMP_REGLIST & 1) == 1) then
								if adr_mode ==	0 then //DAMODE							 
									LDMDA1(TMP_BYTE);
								endif;
								if adr_mode == 1 then //IAMODE
									LDMIA1(TMP_BYTE);
								endif;
								if adr_mode == 2 then //DBMODE
									LDMDB1(TMP_BYTE);
								endif;
								if adr_mode == 3 then //IBMODE
									LDMIB1(TMP_BYTE);
								endif;
							endif;
						endif;
					else
						if (TMP_BYTE != 15) then
							if ((TMP_REGLIST & 1) == 1) then
								if adr_mode == 0 then //DAMODE
									TMP_REG3 = GetGPRIndex(TMP_BYTE);
									LDMDA1(TMP_REG3);
								endif;
								if adr_mode == 1 then //IAMODE
									TMP_REG3 = GetGPRIndex(TMP_BYTE);
									LDMIA1(TMP_REG3); 
								endif;
								if adr_mode == 2 then // DBMODE
									TMP_REG3 = GetGPRIndex(TMP_BYTE);
									LDMDB1(TMP_REG3);
								endif;
								if adr_mode == 3 then //IBMODE
									TMP_REG3 = GetGPRIndex(TMP_BYTE);
									LDMIB1(TMP_REG3);
								endif;
							endif;
						else
							TMP_SWORD = GetSPSR();
							Ucpsr = TMP_SWORD;
							if ((TMP_REGLIST & 1) == 1) then
								if adr_mode  == 0 then //DAMODE
									LDMDA3_NIA();
								endif;
								if adr_mode == 1 then //IAMODE
									LDMIA3_NIA();
								endif;
								if adr_mode == 2 then // DBMODE
									LDMDB3_NIA();
								endif;
								if adr_mode == 3 then //IBMODE
									LDMIB3_NIA();
								endif;
							endif;
						endif;
					endif;
				endif;		
			//Get the next bit
			TMP_REGLIST = TMP_REGLIST >> 1;
			//Increase the register counter
			TMP_BYTE = TMP_BYTE + 1;
			recurs_ldm;
		endif;
	}
	       
