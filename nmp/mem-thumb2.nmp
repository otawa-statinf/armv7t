// ARM ref data
var data8[1, card(8)]
var data16[1, card(16)]
var data32[1, card(32)]
var data64[1, card(64)]


op mem_thumb2 = LDR_imm_Thumb
	| LDRH_reg 
	| STC 
	| LDC_imm 
	| LDM_T2 
	| STR_imm_Thumb
	| STRB_imm 
	| LDRB_imm 
	| MRC_MRC2 
	| STMDB_T1
	| LDREX_T1
	| STRD
	| LDRD


op LDRH_reg(x: LDRH_reg_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	shift_n = x.shift_n
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n);
			Shift_C(R[x.m], x.shift_t, shift_n, APSR_C, offset, APSR_C);				
			offset_addr = if x.add then (R[x.n] + offset) else (R[x.n] - offset) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data16 = M16[address];
			if x.wback then R[x.n] = offset_addr; endif;
			//if UnalignedSupport() || address<0..0> == 0 then
				R[x.t] = ZeroExtend(data16, 32);
			//else // Can only apply before ARMv7
			//	R[t] = bits(32) UNKNOWN;
		endif;
	}

// should provide t, n, m, index, wback, shift_t, shift_n
op LDRH_reg_list = LDRH_T2

op LDRH_T2(rt: REG_INDEX, rn: REG_INDEX, rm: REG_INDEX, imm2: card(2))
	// TODO ranging effects
	//		rn = 1111 -> LDRH (literal)
	//		rt = 1111 -> LDRH (register)
	image = format("11111 00 0 0 01 1 %s %s 0 00000 %2b %s", rn, rt, imm2, rm)
	syntax = format("ldrh.w %s, [%s, %s, LSL #%d]", rt, rn, rm, imm2)
	condition = 1
	t = UInt(rt)
	n = UInt(rn)
	m = UInt(rm)
	index = 1
	add = 1
	wback = 0
	shift_t = SRType_LSL
	shift_n = imm2

	
op LDR_imm_Thumb(x: LDR_imm_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data32 = M32[address];
			if x.wback then R[x.n] = offset_addr; endif;
			if x.t == 15 then
				//if address<1..0> == 0b00 then 
					LoadWritePC(data32); 
				//else UNPREDICTABLE; 
				//endif;
			else //if UnalignedSupport() || address<1:0> == '00' then
				R[x.t] = data32;
			//else R[x.t] = bits(32) UNKNOWN; // Can only apply before ARMv7
			endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op LDR_imm_list = LDR_imm_T3 | LDR_imm_T4

op LDR_imm_T3(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		rn = 1111 -> LDR (literal)
	image = format("11111 00 0 1 10 1 %s %s %12b", Rn, Rt, imm12)
	syntax = format("ldr.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0

op LDR_imm_T4(Rn: REG_INDEX, Rt: REG_INDEX, imm8: card(8), P: card(1), U: card(1), W: card(1))
	// TODO ranging effects
	//		Rn = 1111 -> LDR (literal)
	//	 	P = 1 && U = 1 && W = 0 -> LDRT;
	// 		Rn = 1101 & P = 0 & U = 1 & W = 1 & imm8 = 00000100 -> POP;
	image = format("11111 00 0 0 10 1 %s %s 1 %1b %1b %1b %8b", Rn, Rt, P, U, W, imm8)
	syntax = 
		if P then format("ldr %s, [%s, #%s0x%x]%s", Rt, Rn, if U then '' else '-' endif, imm8, if W then '!' else '' endif) 
		else format("ldr %s, [%s], #%s0x%x", Rt, Rn, if U then '' else '-' endif, imm8) endif
	//if P == '0' && W == '0' then UNDEFINED;
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm8
	index = P
	add = U
	wback = W
	//if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;

op LDRB_imm(x: LDRB_imm_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data8 = M[address];	
			R[x.t] = ZeroExtend(data8, 32);;
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op LDRB_imm_list = LDRB_imm_T2

op LDRB_imm_T2(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		Rt = 1111 -> PLD;
	//		Rn = 1111 -> LDRB (literal)
	image = format("11111 00 0 1 00 1 %s  %s %12b", Rn, Rt, imm12)
	syntax = format("ldrb.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0

op STR_imm_Thumb(x: STR_imm_Thumb_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data32 = R[x.t];
			//if UnalignedSupport() || address<1:0> == '00' then
				M32[address] = data32;
			//else // Can only occur before ARMv7
				//MemU[address,4] = bits(32) UNKNOWN;			
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}
	
// should provide t, n, imm32, index, add, wback
op STR_imm_Thumb_list = STR_imm_T3 | STR_imm_T4

op STR_imm_T3(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	image = format("11111 00 0 1 10 0 %s %s %12b", Rn, Rt, imm12)
	syntax = format("str.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	//if Rn == '1111' then UNDEFINED
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0
	//if t == 15 then UNPREDICTABLE;

op STR_imm_T4(Rn: REG_INDEX, Rt: REG_INDEX, imm8: card(8), P: card(1), U: card(1), W: card(1))
	// TODO ranging effects
	//		P == '1' && U == '1' && W == '0' -> STRT
	// 		Rn == '1101' && P == '1' && U == '0' && W == '1' && imm8 == '00000100' -> PUSH;
	image = format("11111 00 0 0 10 0 %s %s 1 %1b %1b %1b %8b", Rn, Rt, P, U, W, imm8)
	syntax = 
		if P then format("str %s, [%s, #%s0x%x]%s", Rt, Rn, if U then '' else '-' endif, imm8, if W then '!' else '' endif) 
		else format("str %s, [%s], #%s0x%x", Rt, Rn, if U then '' else '-' endif, imm8) endif
	//if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;		
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm8
	index = P
	add = U
	wback = W
	//if t == 15 || (wback && n == t) then UNPREDICTABLE;
	
op STRB_imm(x: STRB_imm_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			M[address] = R[x.t]<0..7>;	
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op STRB_imm_list = STRB_imm_T2

op STRB_imm_T2(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		Rt in 1111 1101 -> UNPREDICTABLE;
	//		Rn = 1111 -> UNDEFINED
	image = format("11111 00 0 1 00 0 %s  %s %12b", Rn, Rt, imm12)
	syntax = format("strb.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	condition = 1
	t = Rt
	n = Rn
	imm32 = ZeroExtend(imm12, 32)
	index = 1
	add = 1
	wback = 0

mode RegisterListThumb(_P: card(1), _M: card(1), _l: card(13)) = _l
	l = _l
	P = _P
	MM = _M
	syntax = format("{%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}",
		if _l<0..0> then format("r0%s", if _l<1..12> || _P || _M then ", " else "" endif) else "" endif,
		if _l<1..1> then format("r1%s", if _l<2..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<2..2> then format("r2%s", if _l<3..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<3..3> then format("r3%s", if _l<4..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<4..4> then format("r4%s", if _l<5..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<5..5> then format("r5%s", if _l<6..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<6..6> then format("r6%s", if _l<7..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<7..7> then format("r7%s", if _l<8..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<8..8> then format("r8%s", if _l<9..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<9..9> then format("r9%s", if _l<10..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<10..10> then format("r10%s", if _l<11..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<11..11> then format("r11%s", if _l<12..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<12..12> then format("r12%s", if _P || _M  then ", " else "" endif) else "" endif,
		if _M then format("lr%s", if _P then ", " else "" endif) else "" endif,
		if _P then "pc" else "" endif)

op LDM_T2(W: bool, Rn: REG_INDEX, register_list: RegisterListThumb)
	// TODO ranging effects
	// 		Rn = 1101 & W = 1 -> POP (Thumb);
	syntax = format("ldm%s.w %s%s, %s", if Rn.number == 0b1101 then "fd" else "ia" endif, Rn, if W then "!" else "" endif, register_list)
	image = format("11101 00 010 %1b 1 %s %1b %1b 0 %13b", W, Rn, register_list.P, register_list.MM, register_list.l)
	action = {
		n = UInt(Rn);
		registers = register_list.P :: register_list.MM :: 0b0 :: register_list.l;
		wback = (W == 1);
		// if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
		// if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
		// if wback && registers<n> == '1' then UNPREDICTABLE;
		address = R[n];
		i = 0; bitcount = 0; loop;
		if registers<15..15> == 1 then
			LoadWritePC(M32[address]);
			bitcount = bitcount + 1;
		endif;
		if wback && registers<n..n> == 0 then R[n] = R[n] + 4 * bitcount; endif;
		// if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN		
	}
	loop = {
		if registers<i..i> == 1 then
			R[i] = M32[address];
			address = address + 4;
			bitcount = bitcount + 1;
		endif;
		i = i + 1;
		if i <= 14 then
			loop;
		endif;
	}


mode RegisterListThumbLtd(_M: card(1), _l: card(13)) = _l
	_P = 0
	l = _l
	P = _P
	MM = _M
	syntax = format("{%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}",
		if _l<0..0> then format("r0%s", if _l<1..12> || _P || _M then ", " else "" endif) else "" endif,
		if _l<1..1> then format("r1%s", if _l<2..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<2..2> then format("r2%s", if _l<3..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<3..3> then format("r3%s", if _l<4..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<4..4> then format("r4%s", if _l<5..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<5..5> then format("r5%s", if _l<6..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<6..6> then format("r6%s", if _l<7..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<7..7> then format("r7%s", if _l<8..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<8..8> then format("r8%s", if _l<9..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<9..9> then format("r9%s", if _l<10..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<10..10> then format("r10%s", if _l<11..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<11..11> then format("r11%s", if _l<12..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<12..12> then format("r12%s", if _P || _M  then ", " else "" endif) else "" endif,
		if _M then format("lr%s", if _P then ", " else "" endif) else "" endif,
		if _P then "pc" else "" endif)

op STMDB_T1(W: bool, Rn: REG_INDEX, register_list: RegisterListThumbLtd)
	// TODO ranging effects
	// 		Rn = 1101 & W = 1 -> PUSH;
	syntax = format("stm%s %s%s, %s", if Rn.number == 0b1101 then "fd" else "db" endif, Rn, if W then "!" else "" endif, register_list)
	image = format("11101 00 100 %1b 0 %s  0 %1b 0 %13b", W, Rn, register_list.MM, register_list.l) 
	action = {
		n = UInt(Rn);
		registers = 0b0 :: register_list.MM :: 0b0 :: register_list.l;
		wback = W;
		//if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
		//if wback && registers<n> == '1' then UNPREDICTABLE;
		i = 14; address = R[n]; loop;
		if wback then R[n] = address; endif;
	}
	loop = {
		if registers<i..i> == 1 then
			address = address - 4;
			M32[address] = R[i];
		endif;
		i = i - 1;
		if i >= 0 then
			loop;
		endif;
	}


op LDREX_T1 (Rn: REG_INDEX, Rt: REG_INDEX, imm8: card(8))
	image = format("11101 00 0 0 1 0 1 %s  %s 1111 %8b", Rn, Rt, imm8)
	syntax = format("ldrex %s, [%s, #%d]", Rt, Rn, imm8)
	t = UInt(Rt)
	n = UInt(Rn)
	imm32 = ZeroExtend(imm8::0b00, 32)
	//if t IN {13,15} || n == 15 then UNPREDICTABLE;
	action = {
		//NullCheckIfThumbEE(n); 
		address = R[n] + imm32; 
		//SetExclusiveMonitors(address,4);
		R[t] = M32[address];
	}
	

op LDRD = LDRD_imm 
	//| LDRD_lit (Handled in LDRD_imm)

op LDRD_imm(x: LDRD_imm_list)
	syntax = x.syntax
	image = x.image
	cond = x.cond
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n); 
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif; 
			address = if x.index then offset_addr else R[x.n] endif;
			//if HaveLPAE() && address<2..0> == 0b000 then // TODO: HaveLPAE() returns TRUE if the implementation includes the Large Physical Address Extension.
			//	data64 = M64[address];
			//	if BigEndian() then // TODO: BigEndian() tests whether big-endian memory accesses are currently selected.
			//		R[x.t] = data64<63..32>;
			//		R[x.t2] = data64<31..0>; 
			//	else
			//		R[x.t] = data64<31..0>;
			//		R[x.t2] = data64<63..32>;
			//	endif;
			//else
				R[x.t] = M32[address];
				R[x.t2] = M32[address+4];
			//endif;
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}
	
op LDRD_imm_list = LDRD_imm_T1

op LDRD_imm_T1(P_U_1_W: enum(3, 7, 10, 11, 14, 15), Rn: REG_INDEX, Rt: REG_INDEX, Rt2: REG_INDEX, imm8: card(8))
	P = P_U_1_W<3..3>
	U = P_U_1_W<2..2>
	W = P_U_1_W<0..0>
	imm_format = format("#%s0x%x", if U then "" else "-" endif, ZeroExtend(imm8 :: 0b00, 32))
	pre_ind_format = format(", %s]%s", imm_format, if W then "!" else "" endif)
	post_ind_format = format("%s]", imm_format)
	syntax = format("ldrd %s, %s, [%s%s", Rt, Rt2, Rn, if P then pre_ind_format else post_ind_format endif)
	image = format("11101 00 %4b 1 %s  %s %s %8b", P_U_1_W, Rn, Rt, Rt2, imm8)
	//if Rn == '1111' then see LDRD (literal) and if W == '1' then UNPREDICTABLE;
	t = UInt(Rt)
	t2 = UInt(Rt2)
	n = UInt(Rn)
	imm32 = ZeroExtend(imm8 :: 0b00, 32)
	index = P 
	add = U
	wback = W
	//if wback && (n == t || n == t2) then UNPREDICTABLE;
	//if n == 15 || t IN {13,15} || t2 IN {13,15} then UNPREDICTABLE;
	cond = 1


op STRD = STRD_imm

op STRD_imm(x: STRD_imm_list)
	syntax = x.syntax
	image = x.image
	cond = x.cond
	action = {
		if ConditionPassed() then
			//NullCheckIfThumbEE(n); 
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif; 
			address = if x.index then offset_addr else R[x.n] endif;
			//if HaveLPAE() && address<2..0> == 0b000 then // TODO: HaveLPAE() returns TRUE if the implementation includes the Large Physical Address Extension.
			//	if BigEndian() then // TODO: BigEndian() tests whether big-endian memory accesses are currently selected.
			//		data64<63..32> = R[x.t];
			//		data64<31..0> = R[x.t2]; 
			//	else
			//		data64<31..0> = R[x.t];
			//		data64<63..32> = R[x.t2];
			//	endif;
			//	M64[address] = data64;
			//else
				M32[address] = R[x.t]; 
				M32[address+4] = R[x.t2];
			//endif;
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}
	
op STRD_imm_list = STRD_imm_T1

op STRD_imm_T1(P: bool, U: bool, W: bool, Rn: REG_INDEX, Rt: REG_INDEX, Rt2: REG_INDEX, imm8: card(8))
	imm_format = format("#%s0x%x", if U then "" else "-" endif, ZeroExtend(imm8 :: 0b00, 32))
	pre_ind_format = format(", %s]%s", imm_format, if W then "!" else "" endif)
	post_ind_format = format("%s]", imm_format)
	syntax = format("strd %s, %s, [%s%s", Rt, Rt2, Rn, if P then pre_ind_format else post_ind_format endif)
	image = format("11101 00 %1b %1b 1 %1b 0 %s  %s %s %8b", P, U, W, Rn, Rt, Rt2, imm8)
	//if P == '0' && W == '0' then SEE "Related encodings";
	t = UInt(Rt)
	t2 = UInt(Rt2)
	n = UInt(Rn)
	imm32 = ZeroExtend(imm8 :: 0b00, 32)
	index = P 
	add = U
	wback = W
	//if wback && (n == t || n == t2) then UNPREDICTABLE;
	//if n == 15 || t IN {13,15} || t2 IN {13,15} then UNPREDICTABLE;
	cond = 1
