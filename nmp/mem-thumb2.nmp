
op mem_thumb2 = LDR_immediate 
	| LDRH_register 
	| STC 
	| LDC_immediate 
	| LDM_T2 
	| STR_immediate 
	| STRB_immediate 
	| LDRB_immediate 
	| MRC_MRC2 
	| STMDB_T1

op LDRH_register(x: ldrh_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations(); NullCheckIfThumbEE(n);
			//Shift_C(R[x.m], x.shift_t, x.shift_n, APSR_C, offset, ASPR_C);
			offset_addr = if x.add then (R[x.n] + offset) else (R[x.n] - offset) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data = M16[address];
			if x.wback then R[x.n] = offset_addr; endif;
			//if UnalignedSupport() || address<0..0> == 0 then
				R[x.t] = ZeroExtend(data, 32);
			//else // Can only apply before ARMv7
			//	R[t] = bits(32) UNKNOWN;
		endif;
	}

// should provide t, n, m, index, wback, shift_t, shift_n
op ldrh_list = LDRH_T2

op LDRH_T2(rt: REG_INDEX, rn: REG_INDEX, rm: REG_INDEX, imm2: card(2))
	// TODO ranging effects
	//		rn = 1111 -> LDRH (literal)
	//		rt = 1111 -> LDRH (register)
	image = format("11111 00 0 0 01 1 %s %s 0 00000 %2b %s", rn, rt, imm2, rm)
	syntax = format("ldrh.w %s, [%s, %s, LSL #%d]", rt, rn, rm, imm2)
	condition = 1
	t = rt
	n = rn
	m = rm
	index = 1
	add = 1
	wback = 0
	shift_t = SRType_LSL
	shift_n = imm2

	
op LDR_immediate(x: ldr_immediate_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations(); NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data = M32[address];
			if x.wback then R[x.n] = offset_addr; endif;
			if x.t == 15 then
				//if address<1..0> == 0b00 then 
					LoadWritePC(data); 
				//else UNPREDICTABLE; 
				//endif;
			else //if UnalignedSupport() || address<1:0> == '00' then
				R[x.t] = data;
			//else R[x.t] = bits(32) UNKNOWN; // Can only apply before ARMv7
			endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op ldr_immediate_list = LDR_immediate_T3 | LDR_immediate_T4

op LDR_immediate_T3(rn: REG_INDEX, rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		rn = 1111 -> LDR (literal)
	image = format("11111 00 0 1 10 1 %s %s %12b", rn, rt, imm12)
	syntax = format("ldr.w %s, [%s, #0x%x]", rt, rn, imm12)
	condition = 1
	t = rt
	n = rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0

op LDR_immediate_T4(Rn: REG_INDEX, Rt: REG_INDEX, imm8: card(8), P: card(1), U: card(1), W: card(1))
	// TODO ranging effects
	//		Rn = 1111 -> LDR (literal)
	//	 	P = 1 && U = 1 && W = 0 -> LDRT;
	// 		Rn = 1101 & P = 0 & U = 1 & W = 1 & imm8 = 00000100 -> POP;
	image = format("11111 00 0 0 10 1 %s %s 1 %1b %1b %1b %8b", Rn, Rt, P, U, W, imm8)
	syntax = 
		if P then format("ldr %s, [%s, #%s0x%x]%s", Rt, Rn, if U then '' else '-' endif, imm8, if W then '!' else '' endif) 
		else format("ldr %s, [%s], #%s0x%x", Rt, Rn, if U then '' else '-' endif, imm8) endif
	//if P == '0' && W == '0' then UNDEFINED;
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm8
	index = P
	add = U
	wback = W
	//if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;

op LDRB_immediate(x: ldrb_immediate_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations(); NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data = M[address];	
			R[x.t] = ZeroExtend(data, 32);;
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op ldrb_immediate_list = LDRB_immediate_T2

op LDRB_immediate_T2(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		Rt = 1111 -> PLD;
	//		Rn = 1111 -> LDRB (literal)
	image = format("11111 00 0 1 00 1 %s  %s %12b", Rn, Rt, imm12)
	syntax = format("ldrb.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0

op STR_immediate(x: str_immediate_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations(); NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			data = R[x.t];
			//if UnalignedSupport() || address<1:0> == '00' then
				M32[address] = data;
			//else // Can only occur before ARMv7
				//MemU[address,4] = bits(32) UNKNOWN;			
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}
	
// should provide t, n, imm32, index, add, wback
op str_immediate_list = STR_immediate_T3 | STR_immediate_T4

op STR_immediate_T3(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	image = format("11111 00 0 1 10 0 %s %s %12b", Rn, Rt, imm12)
	syntax = format("str.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	//if Rn == '1111' then UNDEFINED
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm12
	index = 1
	add = 1
	wback = 0
	//if t == 15 then UNPREDICTABLE;

op STR_immediate_T4(Rn: REG_INDEX, Rt: REG_INDEX, imm8: card(8), P: card(1), U: card(1), W: card(1))
	// TODO ranging effects
	//		P == '1' && U == '1' && W == '0' -> STRT
	// 		Rn == '1101' && P == '1' && U == '0' && W == '1' && imm8 == '00000100' -> PUSH;
	image = format("11111 00 0 0 10 0 %s %s 1 %1b %1b %1b %8b", Rn, Rt, P, U, W, imm8)
	syntax = 
		if P then format("str %s, [%s, #%s0x%x]%s", Rt, Rn, if U then '' else '-' endif, imm8, if W then '!' else '' endif) 
		else format("str %s, [%s], #%s0x%x", Rt, Rn, if U then '' else '-' endif, imm8) endif
	//if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;		
	condition = 1
	t = Rt
	n = Rn
	imm32 = imm8
	index = P
	add = U
	wback = W
	//if t == 15 || (wback && n == t) then UNPREDICTABLE;
	
op STRB_immediate(x: strb_immediate_list)
	image = x.image
	syntax = x.syntax
	cond = x.condition
	action = {
		if ConditionPassed() then
			// EncodingSpecificOperations(); NullCheckIfThumbEE(n);
			offset_addr = if x.add then (R[x.n] + x.imm32) else (R[x.n] - x.imm32) endif;
			address = if x.index then offset_addr else R[x.n] endif;
			M[address] = R[x.t]<0..7>;	
			if x.wback then R[x.n] = offset_addr; endif;
		endif;
	}

// should provide t, n, imm32, index, add, wback
op strb_immediate_list = STRB_immediate_T2

op STRB_immediate_T2(Rn: REG_INDEX, Rt: REG_INDEX, imm12: card(12))
	// TODO ranging effects
	//		Rt in 1111 1101 -> UNPREDICTABLE;
	//		Rn = 1111 -> UNDEFINED
	image = format("11111 00 0 1 00 0 %s  %s %12b", Rn, Rt, imm12)
	syntax = format("strb.w %s, [%s, #0x%x]", Rt, Rn, imm12)
	condition = 1
	t = Rt
	n = Rn
	imm32 = ZeroExtend(imm12, 32)
	index = 1
	add = 1
	wback = 0

mode RegisterListThumb(_P: card(1), _M: card(1), _l: card(13)) = _l
	l = _l
	P = _P
	MM = _M
	syntax = format("{%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}",
		if _l<0..0> then format("r0%s", if _l<1..12> || _P || _M then ", " else "" endif) else "" endif,
		if _l<1..1> then format("r1%s", if _l<2..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<2..2> then format("r2%s", if _l<3..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<3..3> then format("r3%s", if _l<4..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<4..4> then format("r4%s", if _l<5..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<5..5> then format("r5%s", if _l<6..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<6..6> then format("r6%s", if _l<7..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<7..7> then format("r7%s", if _l<8..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<8..8> then format("r8%s", if _l<9..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<9..9> then format("r9%s", if _l<10..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<10..10> then format("r10%s", if _l<11..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<11..11> then format("r11%s", if _l<12..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<12..12> then format("r12%s", if _P || _M  then ", " else "" endif) else "" endif,
		if _M then format("lr%s", if _P then ", " else "" endif) else "" endif,
		if _P then "pc" else "" endif)

op LDM_T2(W: bool, Rn: REG_INDEX, register_list: RegisterListThumb)
	// TODO ranging effects
	// 		Rn = 1101 & W = 1 -> POP (Thumb);
	syntax = format("ldm%s.w %s%s, %s", if Rn.number == 0b1101 then "fd" else "ia" endif, Rn, if W then "!" else "" endif, register_list)
	image = format("11101 00 010 %1b 1 %s %1b %1b 0 %13b", W, Rn, register_list.P, register_list.MM, register_list.l)
	action = {
		n = UInt(Rn);
		registers = register_list.P :: register_list.MM :: 0b0 :: register_list.l;
		wback = (W == 1);
		// if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
		// if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
		// if wback && registers<n> == '1' then UNPREDICTABLE;
		address = R[n];
		i = 0; bitcount = 0; loop;
		if registers<15..15> == 1 then
			LoadWritePC(M32[address]);
			bitcount = bitcount + 1;
		endif;
		if wback && registers<n..n> == 0 then R[n] = R[n] + 4 * bitcount; endif;
		// if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN		
	}
	loop = {
		if registers<i..i> == 1 then
			R[i] = M32[address];
			address = address + 4;
			bitcount = bitcount + 1;
		endif;
		i = i + 1;
		if i <= 14 then
			loop;
		endif;
	}

mode RegisterListThumbLtd(_M: card(1), _l: card(13)) = _l
	_P = 0
	l = _l
	P = _P
	MM = _M
	syntax = format("{%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}",
		if _l<0..0> then format("r0%s", if _l<1..12> || _P || _M then ", " else "" endif) else "" endif,
		if _l<1..1> then format("r1%s", if _l<2..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<2..2> then format("r2%s", if _l<3..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<3..3> then format("r3%s", if _l<4..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<4..4> then format("r4%s", if _l<5..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<5..5> then format("r5%s", if _l<6..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<6..6> then format("r6%s", if _l<7..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<7..7> then format("r7%s", if _l<8..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<8..8> then format("r8%s", if _l<9..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<9..9> then format("r9%s", if _l<10..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<10..10> then format("r10%s", if _l<11..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<11..11> then format("r11%s", if _l<12..12> || _P || _M  then ", " else "" endif) else "" endif,
		if _l<12..12> then format("r12%s", if _P || _M  then ", " else "" endif) else "" endif,
		if _M then format("lr%s", if _P then ", " else "" endif) else "" endif,
		if _P then "pc" else "" endif)

op STMDB_T1(W: bool, Rn: REG_INDEX, register_list: RegisterListThumbLtd)
	// TODO ranging effects
	// 		Rn = 1101 & W = 1 -> PUSH;
	syntax = format("stm%s %s%s, %s", if Rn.number == 0b1101 then "fd" else "db" endif, Rn, if W then "!" else "" endif, register_list)
	image = format("11101 00 100 %1b 0 %s  0 %1b 0 %13b", W, Rn, register_list.MM, register_list.l) 
	action = {
		n = UInt(Rn);
		registers = 0b0 :: register_list.MM :: 0b0 :: register_list.l;
		wback = (W == 1);
		//if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
		//if wback && registers<n> == '1' then UNPREDICTABLE;
		i = 14; address = R[n]; loop;
		if wback then R[n] = address; endif;
	}
	loop = {
		if registers<i..i> == 1 then
			address = address - 4;
			M32[address] = R[i];
		endif;
		i = i - 1;
		if i >= 0 then
			loop;
		endif;
	}
