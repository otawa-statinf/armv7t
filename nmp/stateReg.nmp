
// constants
let LSL = 0
let LSR = 1
let ASR = 2
let ROR = 3

// No of user registers
let GPRNum = 32

// No of spsr registers
let SPSRNum = 5

// Dont switch to high Vector
let hivector = 0 

//Mode of a ARM Processor
let mode_user       = 0b10000
let mode_FIQ        = 0b10001
let mode_IRQ        = 0b10010
let mode_supervisor = 0b10011
let mode_abort      = 0b10111
let mode_undefined  = 0b11011
let mode_system     = 0b11111


// Register file
reg GPR[GPRNum, u32]
	fmt = "R%d"


// Current Program Status Register
reg Ucpsr [1, u32]
reg Uspsr [SPSRNum, u32]


//Register containing the current register output
//reg ALU_OUT [1, u32]


// The link register used in subroutine calls is register 14.
// Alias NOT used for alias analysis complexity
// reg LINK[u32] alias = GPR[14]

// Memory
mem M 	[32, u8]  				// 8-bits word memory
mem M16 [32, u16] alias = M[0]	// 16-bits word memory alias
mem M32 [32, u32] alias = M[0]	// 32-bits word memory alias
//mem UKM[32, u8]  // memory is u8 addressable

//reg UKCOND [1, u8]
//reg UKEA   [1, u8]  
//reg UKDONE [1, u8]
//reg TTARGET [1, u32]
//reg UKGPR  [32, u8]
//reg UKVALUE [256, u8]
//reg LENGTH     [1, s32]
//reg ADDRESS    [256, u32]
//reg VALUE      [256, s8]
//reg LENGTH_GPR [1, s32]
//reg ADDRESS_GPR[128, u32]
//reg REGNUMBER_GPR[128, s32]
//reg BYTENUMBER_GPR[128, s32]
//reg LENGTH_FPR [1, s32]
//reg ADDRESS_FPR[256, u32]
//reg REGNUMBER_FPR[256, s32]
//reg BYTENUMBER_FPR[256, s32]
//reg CONVLENGTH[1, s32]
//reg CONVREGNUMBER[32, s32]
//reg CONVTYPE[32, s32]



var Temp[1,u32]
reg SBIT[1,u1]
reg MSBIT[1,u1]
reg LBIT[1,u1]
reg HBIT[1,u1]
reg B15SET[1,u1]

//Bits for Load/Store instructions
reg BBIT[1,u1]
reg IBIT[1,u1]
reg PBIT[1,u1]
reg UBIT[1,u1]
reg WBIT[1,u1]

reg PSRFMODE[1,u1]
reg PSRSMODE[1,u1]
reg PSRXMODE[1,u1]
reg PSRCMODE[1,u1]

reg RBIT[1,u1]


///////////////////////////////////////////
// Program status registers
///////////////////////////////////////////

//N=1 if the result is negative, N=0 if it is positive or zero
reg NFLAG [1, u1] alias  = Ucpsr<31..31>

//Z=1 if the result of the instruction is zero and to 0 otherwise
reg ZFLAG [1, u1] alias  = Ucpsr<30..30>

//(*)For an addition C is set to 1 if the addition produced a carry and to 0 otherwise
//(*)For a substraction C is set to 0 if the substraction produced a borrow and to 1 otherwise
//(*)For an operation that incorporate a shift operation C is set to the last u1 shifted out 
//   of the value by the shifter
//(*)Else C is normally unchanged.
reg CFLAG [1, u1] alias  = Ucpsr<29..29>

//(*) For an addition V is set to 1 if signed overflow occured
//(*) Else V is normally unchanged
reg VFLAG [1, u1] alias  = Ucpsr<28..28>

//Indicate if an overflow and/or saturation has occured in the DSP instruction
reg QFLAG [1, u1] alias  = Ucpsr<27..27>

//Disable IRQ interrupts when it is set
reg IFLAG [1, u1] alias  = Ucpsr<7..7>

//Disable FIQ interrupts whenit is set
reg FFLAG [1, u1] alias  = Ucpsr<6..6>

//If T=0 Indicates ARM execution else if T=1 indicates Thumb execution
reg  TFLAG [1, u1] alias = Ucpsr<5..5>
reg TBIT [1, u1] alias = Ucpsr<5..5>

//Determine the mode in which the processor operates
reg MBITS [1, u5] alias  = Ucpsr<4..0>

// Program Counters
reg NIA[1, s32]    alias = GPR[15] pc = 1


///////////////////////////////////////////
// Intial Values of some registers
///////////////////////////////////////////
op init ()
	action = { 
		NIA = 0x2000;
		//CIA = 0x2000;
		//PIA = 0x2000;

		//LR
		GPR[14]=0x2000;
		TFLAG = 0;
		//SP
		GPR[13]=0x800; 
		GPR[21]=0x600; 
		GPR[23]=0x400; 
		GPR[25]=0x200;    
		GPR[27]=0x1000; 
		GPR[29]=0x1200; 
		//CPSR in SuperVisor mode   
		Ucpsr = 0x13;
		
		// sp init for validator
		// same vales as gdb
		GPR[13 + 10] = 0x800;
	 }

