////////////////////////////////////////////////////////////////////
//
//	Description of  thumb instructions for ARM Processor in Sim-nML
//
//                See file arm.nmp
//*************************************************************************//
//  date            : July 2006                                         //
//  copyright       : Institut de Recherche en Informatique de Toulouse    //  
//  author          : Tahiry RATSIAMBAHOTRA                                   //  
//  email           : ratsiam@irit.fr, sainrat@irit.fr                       //  
//*************************************************************************//

//*************************************************************************//
//                                                                         //
//  This program is free software; you can redistribute it and/or modify   //
//  it under the terms of the GNU General Public License as published by   //
//  the Free Software Foundation; either version 2 of the License, or      //
//  (at your option) any later version.                                    //
//                                                                         //
//**************************************************************************//

let UNPREDICTABLE =0b11111111111111111111111111111111

mode IMM3(n: u3) = n
	syntax = format("#%d", n)
	image  = format("%3b", n)

mode IMM5 (n : u5) = n
	syntax = format("#%d", n)
	image  = format("%5b", n)

mode IMM7(n: u7) = n
	syntax = format("#%d", n)
	image  = format("%7b", n)

mode IMM8(n: u8) = n
	syntax = format("#%d", n)
	image  = format("%8b", n)

mode SIMM8(n: s8) = n
	syntax = format("#%d", n)
	image  = format("%8b", n)

mode SIMM11(n: s11) = n
	syntax = format("#%d", n)
	image  = format("%11b", n)

mode setR_Ton()=1
	syntax = ""
	image = "1"


mode setR_Toff()=0
	syntax = ""
	image = "0"


mode setR_T = setR_Ton | setR_Toff

//////////////////////////////////////////
// mode for 11bits offset 
//////////////////////////////////////////
mode OFFS11(n: u11) = n
	syntax = format ("%d", n)
	image  = format ("%11b", n)


mode REG_THUMB_INDEX(ro: thumb_index) = ro
	syntax = format("r%d", ro)
	image  = format("%3b", ro)


macro first_bit_on8(v8) = \
	if v8<0..0> == 1 then 7 else \
	if v8<1..1> == 1 then 6 else \
	if v8<2..2> == 1 then 5 else \
	if v8<3..3> == 1 then 4 else \
	if v8<4..4> == 1 then 3 else \
	if v8<5..5> == 1 then 2 else \
	if v8<6..6> == 1 then 1 else \
	if v8<7..7> == 1 then 0 else \
	-1 endif endif endif endif endif endif endif endif \
    
macro syntax_thumb_reg(on_off, num_reg) = \
	if on_off == 1 then \
		format("r%d", num_reg) \
	else \
		"" \
	endif \

//macro syntax_thumb_reg_format(start, idx, v8) = \
//	format("%s%s", if start == idx then "" else if v8<idx..idx> == 0 then "" else ", " endif endif, syntax_thumb_reg(v8<idx..idx>, idx)) \

macro syntax_thumb_reg_format(idx, v8) = \
	format("%s%s", if v8<idx..idx> == 0 then "" else ", " endif, syntax_thumb_reg(v8<idx..idx>, idx)) \

mode THUMB_REG_LIST(r: u8) = r
	image  = format( "%8b", r)
	start = first_bit_on8(r)
	syntax = if start == -1 then "" else
		format("%s%s%s%s%s%s%s%s",
			syntax_reg_format(0, r),
			syntax_reg_format(1, r),
			syntax_reg_format(2, r),
			syntax_reg_format(3, r),
			syntax_reg_format(4, r),
			syntax_reg_format(5, r),
			syntax_reg_format(6, r),
			syntax_reg_format(7, r)
		) endif


// r should be a REG_THUMB_INDEX (from 0 to 7 only)
macro Get_THUMB_GPR(r) = GPR[r]


///////////////////////////////////////////
// All thumb Instructions 
///////////////////////////////////////////

op THUMB(x : THUMB_instr)
	image = x.image
	syntax = x.syntax
	action = {
		NPC = PC + 2;
		PC = PC + 4;
		x.action;
		PC = NPC;
	}
	instruction_set_select = TFLAG == 1
	instruction_set_name = "THUMB"

op THUMB_instr = ADD_thumb | AND_thumb | ASR_thumb | B_thumb | BIC_thumb 
| BLX_thumb | BX_thumb | COMPARE_thumb | EOR_thumb | LDMIA_thumb 
| LDR_thumb | LDRB_thumb | LDRH_thumb | LDRS_thumb | LSL_thumb 
| LSR_thumb | MUL_thumb | MVN_thumb | NEG_thumb 
| ORR_thumb | POP_thumb | PUSH_thumb | ROR_thumb | SBC_thumb
| STMIA_thumb | STR_thumb | STRB_thumb | STRH_thumb | SUB_thumb
| TST_thumb  |  MOV_thumb  
//MOV_thumb use ADD Rd, 0, Rm
//| SWI_thumb  remplacé par B1_thumb cond = 1111
///////////////////////////////////////////
// I Arithmetic Instructions 
///////////////////////////////////////////


op ADD_thumb = ADC_thumb | ADD_imm1_thumb | ADD_imm2_thumb | ADD_imm3_thumb
| ADD_imm4_thumb | ADD_imm5_thumb | ADD_reg1_thumb| ADD_reg2_thumb 


       
op ADC_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX)
	syntax = format("ADC %s, %s",  rd.syntax, rn.syntax)
	image = format("0100000101%s%s", rn.image, rd.image)
	action = {
		TMP_REG1 = Get_THUMB_GPR(rd);
		TMP_REG2 = Get_THUMB_GPR(rn);
		TMP_SWORD = TMP_REG2 + TMP_REG1 + CFLAG;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		TMP_REG1 = Get_THUMB_GPR(rd);
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
			ZFLAG = 1;
		else 
			ZFLAG = 0; 
		endif; 
	}

op ADD_imm1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm:IMM3)
	syntax = 
		if imm == 0 then
			format("MOV %s, %s", rd.syntax, rn.syntax)
		else
			format("ADD %s, %s, %s", rd.syntax, rn.syntax, imm.syntax)
		endif
	image = format("0001110%s%s%s", imm.image, rn.image, rd.image)
	action = {
	            TMP_REG1 = Get_THUMB_GPR(rd);
                    TMP_REG2 = Get_THUMB_GPR(rn);
		    TMP_SWORD = TMP_REG2 + imm; 
		GPR[rd] = TMP_SWORD;
                    CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = Get_THUMB_GPR(rd);
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif; 
		   
	  	}

op ADD_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("ADD %s, %s", rd.syntax,imm.syntax)
	image = format("00110%s%s", rd.image, imm.image)
	action = {
	            TMP_REG1 = Get_THUMB_GPR(rd);
                    TMP_SWORD = TMP_REG1 + imm;
		GPR[rd] = TMP_SWORD;
		    CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = Get_THUMB_GPR(rd);
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif;  
	  	}

op ADD_reg1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	syntax = format("ADD %s, %s, %s", rd.syntax, rn.syntax, rm.syntax)
	image = format("0001100%s%s%s", rm.image, rn.image, rd.image)
	action = {
	            TMP_REG1 = Get_THUMB_GPR(rm);
                    TMP_REG2 = Get_THUMB_GPR(rn);
		    TMP_SWORD = TMP_REG2 + TMP_REG1;
		GPR[rd] = TMP_SWORD;
                    TMP_REG1 = Get_THUMB_GPR(rd);
                    CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = Get_THUMB_GPR(rd);
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif;
		   
	  	}

op ADD_reg2_thumb( H: u1, rd : REG_THUMB_INDEX, rm: REG_INDEX)
	syntax = format("ADD %s, %s", rd.syntax, rm.syntax)
	image = format("01000100%1b%s%s", H, rm.image, rd.image)
	action = {
	            TMP_REG1 = Get_ARM_GPR(rm);
                    TMP_REG2 = Get_ARM_GPR(rd + if H == 1 then 8 else 0 endif);
		    Set_ARM_GPR(rd, TMP_REG2 + TMP_REG1);
	  	}

op ADD_imm3_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("ADD %s, %s", rd.syntax,imm.syntax)
	image = format("10100%s%s", rd.image, imm.image)
	action = {
		GPR[rd] = ((__IADDR + 4) & 0xfffffffc) + (coerce(u32, imm) << 2);
	}

op ADD_imm4_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("ADD %s, %s", rd.syntax,imm.syntax)
	image = format("10101%s%s", rd.image, imm.image)
	action = {
		GPR[rd] = Get_ARM_GPR(13) + (coerce(u32, imm) << 2);
	}


op ADD_imm5_thumb( imm: IMM7)
	syntax = format("ADD SP, %s", imm.syntax)
	image = format("101100000%s", imm.image)
	action = {
		Set_ARM_GPR(13, Get_ARM_GPR(13) + (coerce(u32, imm) << 2));
	}

op AND_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("AND %s, %s", rd.syntax, rm.syntax)
   image = format("0100000000%s%s", rm.image, rd.image)
   action = {
	     TMP_REG1 = GPR[rd] & GPR[rm];
              NFLAG = TMP_REG1<31..31>; 
	      if TMP_REG1 == 0 then 
		 ZFLAG = 1; 
	      else 
		 ZFLAG = 0; 
	      endif; 
              GPR[rd] = TMP_REG1;
	       
	}


op ASR_thumb = ASR1_thumb | ASR2_thumb

op ASR1_thumb(rd : REG_THUMB_INDEX, rm:REG_THUMB_INDEX, imm : IMM5 )
	syntax = format("ASR %s, %s, %s", rd.syntax, rm.syntax, imm.syntax)
	image = format("00010%s%s%s", imm.image, rm.image,rd.image)
	action = {
	     if imm == 0 then
                 TMP_REG1 = GPR[rm];
                 TMP_BIT = TMP_REG1<31..31>;
                 if  TMP_BIT == 0 then
                     GPR[rd] = 0;   
                 else 
                     TMP_REG2 = 0b11111111111111111111111111111111;
                 endif;
             else
                 TMP_IMM = imm -1;
                 CFLAG = TMP_REG1<TMP_IMM..TMP_IMM>;
                 TMP_REG2 = TMP_REG1 >> imm;
             endif;
             NFLAG = TMP_REG2<31..31>;
	         if TMP_REG2 == 0 then
		   ZFLAG = 1;
	         else
		   ZFLAG = 0;
                 endif;
             GPR[rd] = TMP_REG2;
         
	}

op ASR2_thumb(rd : REG_THUMB_INDEX, rs:REG_THUMB_INDEX )
	syntax = format("ASR %s, %s", rd.syntax, rs.syntax)
	image = format("0100000100%s%s", rs.image,rd.image)
	action = {
                  TMP_IMM = GPR[rs]<7..0>;
                  TMP_REG1 = GPR[rd];
                  if TMP_IMM == 0 then
                  else
                     if TMP_IMM < 32 then
                        TMP_IMM2 = TMP_IMM - 1;
                        CFLAG = GPR[rd]<TMP_IMM2..TMP_IMM2>;
                        GPR[rd] = TMP_REG1 >> TMP_IMM;
                     else
                        CFLAG = TMP_REG1<31..31>;
                        if CFLAG == 0 then
                           GPR[rd] = 0;
                        else
                           GPR[rd] =	UNPREDICTABLE;
                        endif;
                      endif;
                   endif;
                  NFLAG = GPR[rd]<31..31>;
                  if GPR[rd] == 0 then
		        ZFLAG = 1;
	          else
		        ZFLAG = 0;
                  endif; 
         
	}



///////////////////////////////////////////
// Branch instruction, conditional if L bit is set
///////////////////////////////////////////
op B_thumb = B1_thumb 
//| B2_thumb en conflit avec BLX il vaut mieux utiliser BLX

// B1_thumb aussi est en conflit avec SWI , je traite ici
//l'interruption ie: op SWI
op B1_thumb(cond : u4,  simm: SIMM8)
           syntax_cond =
                     switch (cond)  {
                      case 0: "BEQ"
                      case 1: "BNE"
                      case 2: "BCS"
                      case 3: "BCC"
		      case 4: "BMI"
		      case 5: "BPL"
		      case 6: "BVS"
		      case 7: "BVC"
		       case 8: "BHI"
                      case 9: "BLS"
                      case 10: "BGE"
                      case 11: "BLT"
		      case 12: "BGT"
		      case 13: "BLE"
		      case 14: "B"
		      case 15: "SWI"
                      }  
	syntax = format("%s %s", syntax_cond, simm.syntax) 
	image = format("1101%4b%s", cond, simm.image)
	action = {
	         if (cond == 15 ) then
                                 "swi_impl"(simm);
                  endif;  	        
	       if (calcul_condition(cond)) then
                       TMP_REG1 = __IADDR + 8;
                       TMP_IMM = coerce(s32, simm) << 1; 
                       TMP_REG2 = TMP_REG1 + TMP_IMM;
                       NPC = TMP_REG2;
	       	   
	       endif;
	       }

op B2_thumb( signed_immed_11 : SIMM11)
	syntax = format("B %s",signed_immed_11.syntax) 
	image = format("11100%s", signed_immed_11.image)
	action = {
                       TMP_REG1 = __IADDR + 8;
                       TMP_ELEV  =  coerce(s32, signed_immed_11) << 1; 
                       TMP_REG2 = TMP_REG1 + TMP_IMM;
                       NPC = TMP_REG2;
	     
	       }




op BIC_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("BIC %s, %s", rd.syntax, rm.syntax)
   image = format("0100001110%s%s", rm.image, rd.image)
   action = {
	    TMP_REG1 = GPR[rd];
          //  TMP_REG2 = !GPR[rm]<31..0>;
            GPR[rd] = TMP_REG1 & TMP_REG2;
            NFLAG = GPR[rd]<31..31>;
           TMP_REG1 = GPR[rd];
	   if TMP_REG1 == 0 then 
		 ZFLAG = 1; 
	      else 
		 ZFLAG = 0; 
	      endif; 
	   }

op BKPT_thumb(imm: IMM8)
        syntax = format("BKPT %s",imm.syntax) 
	image = format("10111110%s", imm.image)
	action = {
                      

                        TMP_REG1 = __IADDR + 8;
                       TMP_ELEV  =  coerce(u32, imm) << 1; 
                       TMP_REG2 = TMP_REG1 + TMP_IMM;
                       NPC = TMP_REG2;
	     
	       }

op BLX_thumb =BLX1_thumb | BLX2_thumb


op BLX1_thumb(H : u2,offs :OFFS11)
	syntax = format("BL%s %s", if H == 1 then "X" else "" endif, offs.syntax)
	image  = format("111%2b%s",H,offs.image)
	action = {
                                   
                 if (H == 2) then
                           Set_ARM_GPR(14, __IADDR + 4 +(coerce(s32,offs) << 12));
                 else 
                 if (H == 3) then
			    NPC = Get_ARM_GPR(14) + (coerce(u32, offs) << 1);
                            Set_ARM_GPR(14, (__IADDR + 2) | 1);           
                 else 
                 if (H == 1) then
                          Set_ARM_GPR(15, (Get_ARM_GPR(14) + (coerce(u32, offs) << 1)) & 0xfffffffc);
			  Set_ARM_GPR(14 , (__IADDR + 2) | 1);
                          TBIT = 0;   
                  endif;
                  endif;
                  endif;        
	    	       
                    }

op BLX2_thumb( rm: REG_INDEX)
	syntax = format("BLX %s", rm.syntax)
	image  = format("010001111%s000",rm.image)
	action = {
                   Set_ARM_GPR(14, (__IADDR + 2) | 1);
                   TMP_REG1 = Get_ARM_GPR(rm);
                   TFLAG = TMP_REG1<0..0>;
                   NPC = TMP_REG1 & 0xfffffffe;
	       }


op BX_thumb(rm : REG_INDEX)
	syntax = format("BX %s", rm.syntax)
	image  = format("010001110%s000", rm.image)
	action = {
                    
               TMP_REG1 = Get_ARM_GPR(rm); 
               TFLAG = TMP_REG1<0..0>;
               NPC = coerce(u32, TMP_REG1<31..1>) << 1;
	       }



op COMPARE_thumb = CMN_shr_thumb | CMP_imm_thumb | CMP_shr1_thumb
 | CMP_shr2_thumb

op CMN_shr_thumb(rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("CMN %s, %s", rn.syntax, rm.syntax)
   image = format("0100001011%s%s", rm.image,  rn.image)
   action= {
             TMP_REG1 = GPR[rn];
             TMP_REG2 = GPR[rm];
	     Temp = TMP_REG1 + TMP_REG2; 
	     NFLAG = Temp<31..31>; 
	     if Temp == 0 then 
		ZFLAG = 1; 
             else 
	       ZFLAG = 0; 
	     endif; 
	     CFLAG =  CarryFromAdd(TMP_REG1,TMP_REG2,Temp); 
	     VFLAG =  OverflowFromAdd(TMP_REG1,TMP_REG2,Temp);
	}


op CMP_imm_thumb(rn : REG_THUMB_INDEX, imm : IMM8)
	syntax = format("CMP %s, %s", rn.syntax, imm.syntax)
	image = format("00101%s%s", rn.image, imm.image)
	action = {
	     TMP_REG1 = GPR[rn];
	     Temp = TMP_REG1 - imm; 
	     NFLAG = Temp<31..31>; 
	     if Temp == 0 then 
		ZFLAG = 1; 
	     else 
		  ZFLAG = 0; 
	     endif; 
	     CFLAG =  CarryFromSub(TMP_REG1,imm,Temp); 
	     VFLAG =  OverflowFromSub(TMP_REG1,imm,Temp);
	   
	}

op CMP_shr1_thumb(rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("CMP %s, %s", rn.syntax,rm.syntax )
   image = format("0100001010%s%s", rn.image,  rm.image)
   action = {
	     TMP_REG1 = GPR[rn];
             TMP_REG2 = GPR[rm];     
   	     Temp = TMP_REG1 - TMP_REG2; 
	     NFLAG = Temp<31..31>; 
	     if Temp == 0 then 
		ZFLAG = 1; 
	     else 
		  ZFLAG = 0; 
	     endif; 
	     CFLAG =  CarryFromSub(TMP_REG1,TMP_REG2,Temp); 
	     VFLAG =  OverflowFromSub(TMP_REG1,TMP_REG2,Temp);
	}

op CMP_shr2_thumb(H: u1, rn : REG_THUMB_INDEX, rm : REG_INDEX)
   syntax = format("CMP %s, %s", rn.syntax,rm.syntax ) 
   image = format("01000101%1b%s%s", H, rm.image,  rn.image)
   action = {
            
	     TMP_REG1 = Get_ARM_GPR(rn + if H == 1 then 8 else 0 endif);
             TMP_REG2 = Get_ARM_GPR(rm);     
   	     Temp = TMP_REG1 - TMP_REG2; 
	     NFLAG = Temp<31..31>; 
	     if Temp == 0 then 
		ZFLAG = 1; 
	     else 
		  ZFLAG = 0; 
	     endif; 
	     CFLAG =  CarryFromSub(TMP_REG1,TMP_REG2,Temp); 
	     VFLAG =  OverflowFromSub(TMP_REG1,TMP_REG2,Temp);
	}




op EOR_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("EOR %s, %s", rd.syntax, rm.syntax)
   image = format("0100000001%s%s", rm.image, rd.image)
   action = {
       TMP_REG1 = GPR[rd];
       TMP_REG2 = GPR[rm];
       TMP_SWORD = TMP_REG2 ^ TMP_REG1; 
       NFLAG = TMP_SWORD<31..31>; 
	      if TMP_SWORD == 0 then 
		 ZFLAG = 1; 
	      else 
		 ZFLAG = 0; 
	      endif; 
	 GPR[rd] = TMP_SWORD;
	}

op LDMIA_thumb(rn: REG_THUMB_INDEX, llist: THUMB_REG_LIST)
   syntax = format("LDMIA %s!, {%s}", rn.syntax, llist.syntax)
   image = format("11001%s%s", rn.image, llist.image)
   action = {
		  //reg_list.action;
                  TMP_REGLIST = llist;		  
		  //Compute number of set bits in the register list to compute the start address
		  TMP_IMM  = 0;
		  TMP_SETBIT = 0;
		  B15SET = 0;
                  TMP_REG1 = GPR[rn];
		  number_of_set_bits_in;
                  TMP_START_ADDR = TMP_REG1; 
		  TMP_END_ADDR = TMP_REG1 + (TMP_SETBIT * 4) - 4;
                  TMP_IMM = 0;
                  boucle;
                  TMP_END_ADDR = TMP_START_ADDR - 4;
                  GPR[rn] = TMP_REG1 + TMP_SETBIT * 4;              
 //Note that the assert mode is not implemented, programmer may take
  //		  care of the address in paramater !                            

             }
   number_of_set_bits_in = {
	     //Count the amount of bits into the list
             if (TMP_IMM != 8) then
		  if (TMP_REGLIST & 1 == 1) then
		     TMP_SETBIT = TMP_SETBIT + 1;
		     if (TMP_IMM == 7) then
			B15SET = 1;
		     endif;		     
		  endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
		  TMP_IMM = TMP_IMM + 1;
		  number_of_set_bits_in;
	       endif;
	       }  

    boucle = {
               if (TMP_IMM != 8) then
                    if (TMP_REGLIST & 1 == 1) then
		        GPR[TMP_IMM] = M[TMP_START_ADDR];
			TMP_START_ADDR = TMP_START_ADDR + 4;
		    endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
                  TMP_IMM = TMP_IMM + 1;
	          boucle;
                endif;
               }

op LDR_thumb = LDR_imm_thumb | LDR_shr_thumb | LDR_imm2_thumb| LDR_imm3_thumb

op LDR_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("LDR %s, [%s, %s * 4]", rd.syntax, rn.syntax, imm.syntax)
	image = format("01101%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 4;
		 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;
                 
                 } 

op LDR_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("LDR %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101100%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;
                 
                 } 

op LDR_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("LDR %s, [PC, %s * 4]", rd.syntax, imm.syntax)
	image = format("01001%s%s", rd.image, imm.image)
	action = {
	         TMP_REG1 = __IADDR + 8;
		 TMP_REG2 = coerce(u32, TMP_REG1<31..2>) << 2;
		 TMP_START_ADDR  =  TMP_REG2 + imm * 4;
		 GPR[rd] = M[TMP_START_ADDR];
                                
                 } 

op LDR_imm3_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("LDR %s, [SP, %s * 4]", rd.syntax, imm.syntax)
	image = format("10011%s%s", rd.image, imm.image)
	action = {
		 TMP_START_ADDR = Get_ARM_GPR(13) + (coerce(u32, imm) << 2);
                 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;
		                               
                 } 


op LDRB_thumb = LDRB_imm_thumb | LDRB_shr_thumb

op LDRB_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("LDRB %s, [%s, %s]", rd.syntax, rn.syntax, imm.syntax)
	image = format("01111%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm ;
		 TMP_IMM = M[TMP_START_ADDR];
                 GPR[rd] = TMP_IMM;
               
                 } 

op LDRB_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("LDRB %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101110%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_IMM = M[TMP_START_ADDR];
                 GPR[rd] = TMP_IMM;
                 
                 } 


op LDRH_thumb = LDRH_imm_thumb | LDRH_shr_thumb

op LDRH_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("LDRH %s, [%s, %s * 2]", rd.syntax, rn.syntax, imm.syntax)
	image = format("10001%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 2;
		 TMP_REGLIST = M[TMP_START_ADDR];
                 GPR[rd] = TMP_REGLIST;
               
                 } 


op LDRH_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("LDRH %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101101%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_BIT = TMP_START_ADDR<0..0>;
                 if (TMP_BIT == 0) then
                      TMP_REGLIST = M[TMP_START_ADDR];
                 else
                    TMP_REGLIST = UNPREDICTABLE;
                  endif;
		 GPR[rd] = TMP_REGLIST;
                 
                 } 

op LDRS_thumb = LDRSB_thumb | LDRSH_thumb

op LDRSB_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("LDRSB %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101011%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_IMM = M[TMP_START_ADDR];
		 TMP_BIT = TMP_IMM<7..7>;
		 if (TMP_BIT == 1) then
		    TMP_REG1 = UNPREDICTABLE;
		    TMP_REG1 = TMP_REG1 << 8;
		    TMP_REG2 = TMP_REG1 + TMP_IMM;
		  else
			TMP_REG2 = TMP_IMM;
	          endif;
                 GPR[rd] = TMP_REG2;
		                  
                 } 

op LDRSH_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("LDRSH %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101111%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_BIT = TMP_START_ADDR<0..0>;
                 if (TMP_BIT == 0) then
		  		TMP_REGLIST = M[TMP_START_ADDR];
				TMP_BIT = TMP_REGLIST<15..15>;
				if (TMP_BIT == 1) then
				   TMP_REG1 = UNPREDICTABLE;
				   TMP_REG1 = TMP_REG1 << 16;
				   TMP_REG2 = TMP_REG1 + TMP_REGLIST;
				else
					TMP_REG2 = TMP_REGLIST;
	                        endif;
		       else
	        	        TMP_REG2 = UNPREDICTABLE;
	          endif;
                 GPR[rd] = TMP_REG2;
		                  
                 } 

op LSL_thumb = LSL_imm_thumb | LSL_shr_thumb

op LSL_imm_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("LSL %s, %s, %s", rd.syntax, rm.syntax, imm.syntax)
	image = format("00000%s%s%s", imm.image, rm.image, rd.image)
	action = {  
	       if (imm == 0) then
	         TMP_REG1 = GPR[rm];
                else
                   TMP_IMM = 32 - imm;
		   CFLAG = GPR[rm]<TMP_IMM..TMP_IMM>;
		   TMP_REG1 = GPR[rm] << imm;
	        endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
	        else 
		   ZFLAG = 0; 
	        endif; 	   
		GPR[rd]= TMP_REG1;
            }

op LSL_shr_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	syntax = format("LSL %s, %s", rd.syntax, rs.syntax)
	image = format("0100000010%s%s", rs.image, rd.image)
	action = {  
		 TMP_IMM = GPR[rs]<7..0>;
		 TMP_REG1 = GPR[rd];
	       if (TMP_IMM == 0) then
	         else
		   if (TMP_IMM < 32) then
		      TMP_IMM2 = 32 - TMP_IMM;
		      CFLAG = TMP_REG1<TMP_IMM2..TMP_IMM2>;
		      TMP_REG1 = TMP_REG1 << TMP_IMM;
		      
		   else	
                       if (TMP_IMM == 32)  then
		           CFLAG = TMP_REG1<0..0>;
			   TMP_REG1 = 0;

		       else 
                            if (TMP_IMM > 32)  then
			       CFLAG = 0;
			       TMP_REG1 = 0;
			    endif;
		       endif;

		   endif;
               endif;	
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
	        else 
		   ZFLAG = 0; 
	        endif; 	   
		GPR[rd]= TMP_REG1;
            }

op LSR_thumb = LSR_imm_thumb | LSR_shr_thumb

op LSR_imm_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("LSR %s, %s, %s", rd.syntax, rm.syntax, imm.syntax)
	image = format("00001%s%s%s", rm.image, rd.image, imm.image)
	action = {  
		 TMP_REG1 = GPR[rd];
		 TMP_REG2 = GPR[rm];
	       if (imm == 0) then
	       	 CFLAG = TMP_REG1<31..31>;
	         TMP_REG1 = 0;
                else
                   TMP_IMM = imm - 1;
		   CFLAG = TMP_REG1<TMP_IMM..TMP_IMM>;
		   TMP_REG1 = GPR[rm] >> imm;
	        endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
	        else 
		   ZFLAG = 0; 
	        endif; 	   
		GPR[rd]= TMP_REG1;
            }

op LSR_shr_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	syntax = format("LSR %s, %s", rd.syntax, rs.syntax)
	image = format("0100000011%s%s", rs.image, rd.image)
	action = {  
		 TMP_IMM = GPR[rs]<7..0>;
		 TMP_REG1 = GPR[rd];
	       if (TMP_IMM == 0) then
	         else
		   if (TMP_IMM < 32) then
		      TMP_IMM2 =  TMP_IMM - 1;
		      CFLAG = TMP_REG1<TMP_IMM2..TMP_IMM2>;
		      TMP_REG1 = TMP_REG1 >> TMP_IMM;
		      
		   else	
                       if (TMP_IMM == 32)  then
		           CFLAG = TMP_REG1<31..31>;
			   TMP_REG1 = 0;

		       else 
                            if (TMP_IMM > 32)  then
			       CFLAG = 0;
			       TMP_REG1 = 0;
			    endif;
		       endif;

		   endif;
               endif;	
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
	        else 
		   ZFLAG = 0; 
	        endif; 	   
		GPR[rd]= TMP_REG1;
            }

op MOV_thumb = MOV_imm_thumb | MOV_shr2_thumb
//| MOV_shr_thumb the same as ADD R%d R%d #0 

op MOV_imm_thumb(rd : REG_THUMB_INDEX, imm : IMM8)
	syntax = format("MOV %s, %s", rd.syntax, imm.syntax)
	image = format("00100%s%s", rd.image, imm.image)
	action = {
	     TMP_REG1 = imm;
	     NFLAG = TMP_REG1<31..31>; 
	     if TMP_REG1 == 0 then 
		ZFLAG = 1; 
	     else 
		  ZFLAG = 0; 
	     endif; 
	    GPR[rd] = TMP_REG1;
	   
	}

op MOV_shr_thumb(rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX)
	syntax = format("MOV %s, %s", rd.syntax, rn.syntax)
	image = format("0001110000%s%s", rn.image, rd.image)
	action = {
	     TMP_REG1 = GPR[rn];
	     NFLAG = TMP_REG1<31..31>; 
	     if TMP_REG1 == 0 then 
		ZFLAG = 1; 
	     else 
		  ZFLAG = 0; 
	     endif; 
	    GPR[rd] = TMP_REG1;
	   
	}


op MOV_shr2_thumb(H: u1, rd : REG_THUMB_INDEX, rm : REG_INDEX)
	syntax = format("MOV %s, %s", rd.syntax, rm.syntax)
	image = format("01000110%1b%s%s", H, rm.image, rd.image)
        
	action = {
	    Set_ARM_GPR(rd + if H == 1 then 8 else 0 endif, Get_ARM_GPR(rm));
	   
	}




op MUL_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
       	syntax = format("MUL %s, %s", rd.syntax, rm.syntax)
	image = format("0100001101%s%s", rm.image, rd.image)
	action = {
	       TMP_REG1 = GPR[rd];
	       TMP_REG1= GPR[rm] * TMP_REG1;
	        NFLAG = TMP_REG1<31..31>; 
		 if TMP_REG1 == 0 then 
		    ZFLAG = 1; 
		 else 
		    ZFLAG = 0; 
		 endif; 
		 GPR[rd] = TMP_REG1;
	   
	}

op MVN_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
       	syntax = format("MVN %s, %s", rd.syntax, rm.syntax)
	image = format("0100001111%s%s", rm.image, rd.image)
	action = {
	       TMP_REG1 = ~GPR[rm];
	       NFLAG = TMP_REG1<31..31>; 
		 if TMP_REG1 == 0 then 
		    ZFLAG = 1; 
		 else 
		    ZFLAG = 0; 
		 endif; 
		 GPR[rd] = TMP_REG1;
	   
	}

op NEG_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
       	syntax = format("NEG %s, %s", rd.syntax, rm.syntax)
	image = format("0100001001%s%s", rm.image, rd.image)
	action = {
	       TMP_SWORD = 0 - GPR[rm];
	       Temp = 0;
	       NFLAG = TMP_SWORD<31..31>; 
		 if TMP_SWORD == 0 then 
		    ZFLAG = 1; 
		 else 
		    ZFLAG = 0; 
		 endif; 
		 GPR[rd] = TMP_SWORD;
		 TMP_REG1 = 0;
	     CFLAG = ~ CarryFromSub(TMP_REG1, TMP_SWORD,Temp); 
	     VFLAG =  OverflowFromSub(TMP_REG1, TMP_SWORD,Temp);
	}

op ORR_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
       	syntax = format("ORR %s, %s", rd.syntax, rm.syntax)
	image = format("0100001100%s%s", rm.image, rd.image)
	action = {
	       TMP_REG1 = GPR[rd] | GPR[rm];
	        NFLAG = TMP_REG1<31..31>; 
		 if TMP_REG1 == 0 then 
		    ZFLAG = 1; 
		 else 
		    ZFLAG = 0; 
		 endif; 
		 GPR[rd] = TMP_REG1;
	   
	}


op POP_thumb(R: setR_T, llist: THUMB_REG_LIST)
   syntax = format("POP {%s}", llist.syntax)
   image = format("1011110%s%s", R.image, llist.image)
   action = {
	  
                 // reg_list.action;
		  TMP_REGLIST = llist;		  
		  //Compute number of set bits in the register list to compute the start address
		  TMP_IMM  = 0;
		  TMP_SETBIT = 0;
		  B15SET = 0;
                  TMP_REG1 = Get_ARM_GPR(13);
		  number_of_set_bits_in;
                  TMP_START_ADDR = TMP_REG1; 
		  TMP_END_ADDR = TMP_REG1 + ((R + TMP_SETBIT) * 4  ) ;
                  TMP_IMM = 0;
                  boucle;
		  if (R == 1) then
		     TMP_REG2 = M[TMP_START_ADDR];
		     TMP_START_ADDR = TMP_START_ADDR + 4;
		     TBIT = TMP_REG2<0..0>;
		     TFLAG = TBIT;
		     TMP_START_ADDR = TMP_START_ADDR + 4;
		  endif;
                  Set_ARM_GPR(13, TMP_END_ADDR);
                            
 //Note that the assert mode is not implemented, programmer may take
  //		  care of the address in paramater !                            

             }
   number_of_set_bits_in = {
	     //Count the amount of bits into the list
             if (TMP_IMM != 8) then
		  if (TMP_REGLIST & 1 == 1) then
		     TMP_SETBIT = TMP_SETBIT + 1;
		     if (TMP_IMM == 7) then
			B15SET = 1;
		     endif;		     
		  endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
		  TMP_IMM = TMP_IMM + 1;
		  number_of_set_bits_in;
	       endif;
	       }  

    boucle = {
               if (TMP_IMM != 8) then
                    if (TMP_REGLIST & 1 == 1) then
		        GPR[TMP_IMM] = M[TMP_START_ADDR];
			TMP_START_ADDR = TMP_START_ADDR + 4;
		    endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
                  TMP_IMM = TMP_IMM + 1;
	          boucle;
                endif;
               }


op PUSH_thumb(R: setR_T, llist: THUMB_REG_LIST)
   syntax = format("PUSH {%s}", llist.syntax)
   image = format("1011010%s%s", R.image, llist.image)
   action = {
	  
                  //reg_list.action;
		  TMP_REGLIST = llist;		  
		  //Compute number of set bits in the register list to compute the start address
		  TMP_IMM  = 0;
		  TMP_SETBIT = 0;
		  B15SET = 0;
                  TMP_REG1 = Get_ARM_GPR(13);
		  number_of_set_bits_in;
                  TMP_START_ADDR = TMP_REG1 -((R + TMP_SETBIT) * 4  ) ; 
		  TMP_END_ADDR = TMP_START_ADDR ;
                  TMP_IMM = 0;
                  boucle;
		  if (R == 1) then
		     TMP_REG2 = Get_ARM_GPR(14);
		     M[TMP_START_ADDR] = TMP_REG2;
		     TMP_START_ADDR = TMP_START_ADDR + 4;
		   endif;
                   Set_ARM_GPR(13, TMP_END_ADDR);
   //Note that the assert mode is not implemented, programmer may take
  //		  care of the address in paramater !                            

             }
   number_of_set_bits_in = {
	     //Count the amount of bits into the list
             if (TMP_IMM != 8) then
		  if (TMP_REGLIST & 1 == 1) then
		     TMP_SETBIT = TMP_SETBIT + 1;
		     if (TMP_IMM == 7) then
			B15SET = 1;
		     endif;		     
		  endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
		  TMP_IMM = TMP_IMM + 1;
		  number_of_set_bits_in;
	       endif;
	       }  

    boucle = {
               if (TMP_IMM != 8) then
                    if (TMP_REGLIST & 1 == 1) then
		        M[TMP_START_ADDR] = GPR[TMP_IMM];
			TMP_START_ADDR = TMP_START_ADDR + 4;
		    endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
                  TMP_IMM = TMP_IMM + 1;
	          boucle;
                endif;
               }

op ROR_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	syntax = format("ROR %s, %s", rd.syntax, rs.syntax)
	image = format("0100000111%s%s", rs.image, rd.image)
	action = {  
		 TMP_IMM =  GPR[rs]<7..0>;
		 TMP_FIVE = GPR[rs]<4..0>; 
		 TMP_REG1 = GPR[rd];
	       if (TMP_IMM == 0) then
	         else
		   if (TMP_FIVE == 0) then
		    //  TMP_IMM2 =  TMP_IMM - 1;
		      CFLAG = TMP_REG1<31..31>;
		    else 
			    TMP_IMM2 = TMP_FIVE - 1;
			    // in the next line, index was missing after GPR
			    // not sure if [rd] is the good one
			    CFLAG = GPR[rd]<TMP_IMM2..TMP_IMM2>;
			    TMP_REG1 = TMP_REG1 >>> TMP_FIVE;
                          
		     endif;

		   endif;
                NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
	        else 
		   ZFLAG = 0; 
	        endif; 	   
		GPR[rd]= TMP_REG1;
            }


op SBC_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
   syntax = format("SBC %s, %s", rd.syntax, rm.syntax)
   image = format("0100000110%s%s", rm.image, rd.image)
   action = {
	        TMP_REG1 = GPR[rd];
		TMP_REG2 = GPR[rm];
		TMP_BIT = !CFLAG;
		TMP_SWORD = TMP_REG1 - TMP_REG2 - !CFLAG; 
		TMP_REG1 = TMP_SWORD;
		NFLAG = TMP_REG1<31..31>; 
		if TMP_REG1 == 0 then 
		   ZFLAG = 1; 
		   else 
		 ZFLAG = 0; 
		 endif; 
// a revoir \
	      CFLAG =  ! CarryFromSub(TMP_REG1,TMP_REG1, TMP_BIT);
	      VFLAG = OverflowFromSub(TMP_REG1,TMP_REG1,TMP_BIT); 
	    
	 
	}

op STMIA_thumb(rn: REG_THUMB_INDEX, llist: THUMB_REG_LIST)
   syntax = format("STMIA %s!, {%s}", rn.syntax, llist.syntax)
   image = format("11000%s%s", rn.image, llist.image)
   action = {
		  //reg_list.action;
                  TMP_REGLIST = llist;		  
		  //Compute number of set bits in the register list to compute the start address
		  TMP_IMM  = 0;
		  TMP_SETBIT = 0;
		  B15SET = 0;
                  TMP_REG1 = GPR[rn];
		  number_of_set_bits_in;
                  TMP_START_ADDR = TMP_REG1;
		  TMP_END_ADDR = TMP_REG1 + (TMP_SETBIT * 4) - 4;
                  TMP_IMM = 0;
                  boucle;
                  TMP_END_ADDR = TMP_START_ADDR - 4;
                  GPR[rn] = TMP_REG1 + TMP_SETBIT * 4;              
 //Note that the assert mode is not implemented, programmer may take
  //		  care about the address in paramater !                            

             }
   number_of_set_bits_in = {
	     //Count the amount of bits into the list
             if (TMP_IMM != 8) then
		  if (TMP_REGLIST & 1 == 1) then
		     TMP_SETBIT = TMP_SETBIT + 1;
		     if (TMP_IMM == 7) then
			B15SET = 1;
		     endif;		     
		  endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
		  TMP_IMM = TMP_IMM + 1;
		  number_of_set_bits_in;
	       endif;
	       }  

    boucle = {
               if (TMP_IMM != 8) then
                    if (TMP_REGLIST & 1 == 1) then
		        M[TMP_START_ADDR] = GPR[TMP_IMM] ;
			TMP_START_ADDR = TMP_START_ADDR + 4;
		    endif;
		  TMP_REGLIST = TMP_REGLIST >> 1;
                  TMP_IMM = TMP_IMM + 1;
	          boucle;
                endif;
               }

op STR_thumb = STR_imm_thumb | STR_shr_thumb | STR_imm2_thumb

op STR_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("STR %s, [%s, %s * 4]", rd.syntax, rn.syntax, imm.syntax)
	image = format("01100%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 4;
		 if ((TMP_START_ADDR & 3 ) == 0) then
                      M[TMP_START_ADDR] =  GPR[rd];
                 else
                    M[TMP_START_ADDR] = UNPREDICTABLE;
                  endif;
                                
                 } 

op STR_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("STR %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101000%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 if ((TMP_START_ADDR & 3 ) == 0) then
                       M[TMP_START_ADDR] = GPR[rd];
                 else
                     M[TMP_START_ADDR] = UNPREDICTABLE;
                  endif;
                 
                 
                 } 



op STR_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("STR %s, [SP, %s * 4]", rd.syntax, imm.syntax)
	image = format("10010%s%s", rd.image, imm.image)
	action = {
	         TMP_REG1 = Get_ARM_GPR(13); // SP
		 TMP_START_ADDR = TMP_REG1 + imm *4;
                 if ((TMP_START_ADDR & 3 ) == 0) then
                      M[TMP_START_ADDR] = GPR[rd];
                 else
                    M[TMP_START_ADDR] = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;
		                               
                 } 


op STRB_thumb = STRB_imm_thumb | STRB_shr_thumb

op STRB_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("STRB %s, [%s, %s]", rd.syntax, rn.syntax, imm.syntax)
	image = format("01110%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm ;
		 TMP_IMM2 = GPR[rd]<7..0>; 
		 M[TMP_START_ADDR] = TMP_IMM2;
                  } 

op STRB_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("STRB %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101010%s%s%s", rm.image, rn.image, rd.image)
	action = {
		  TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		  TMP_IMM2 = GPR[rd]<7..0>; 
		  M[TMP_START_ADDR] = TMP_IMM2;
                 } 


op STRH_thumb = STRH_imm_thumb | STRH_shr_thumb

op STRH_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	syntax = format("STRH %s, [%s, %s * 2]", rd.syntax, rn.syntax, imm.syntax)
	image = format("10000%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 2;
		 TMP_REGLIST = GPR[rd]<15..0>;
                 if ((TMP_START_ADDR & 3 ) == 0) then
                      M[TMP_START_ADDR] = TMP_REGLIST;
                 else
                    M[TMP_START_ADDR] = UNPREDICTABLE;
                  endif;
		              
                 } 


op STRH_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	syntax = format("STRH %s, [%s, %s ]", rd.syntax, rn.syntax, rm.syntax)
	image = format("0101001%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_REGLIST = GPR[rd]<15..0>;
                 if ((TMP_START_ADDR & 3 ) == 0) then
                      M[TMP_START_ADDR] = TMP_REGLIST;
                 else
                    M[TMP_START_ADDR] = UNPREDICTABLE;
                  endif;
                
                 } 


op SUB_thumb =  SUB_imm1_thumb | SUB_imm2_thumb | SUB_imm3_thumb
|  SUB_reg_thumb 

op SUB_imm1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM3)
	syntax = format("SUB %s, %s, %s", rd.syntax, rn.syntax, imm.syntax)
	image = format("0001111%s%s%s", imm.image, rn.image, rd.image)
	action = {
	            TMP_REG1 = Get_THUMB_GPR(rd);
                    TMP_REG2 = Get_THUMB_GPR(rn);
		    TMP_SWORD = TMP_REG2 - imm; 
		    GPR[rd] = TMP_SWORD;
                    CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = Get_THUMB_GPR(rd);
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif; 
		   
	  	}

op SUB_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	syntax = format("SUB %s, %s", rd.syntax,imm.syntax)
	image = format("00111%s%s", rd.image, imm.image)
	action = {
	            TMP_REG1 = Get_THUMB_GPR(rd);
                    TMP_SWORD = TMP_REG1 - imm; 
		    GPR[rd] = TMP_SWORD;
		    CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = GPR[rd];
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif;  
	  	}

op SUB_reg_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	syntax = format("SUB %s, %s, %s", rd.syntax, rn.syntax, rm.syntax)
	image = format("0001101%s%s%s", rm.image, rn.image, rd.image)
	action = {
	            TMP_REG1 = GPR[rm];
                    TMP_REG2 = GPR[rn];
		    TMP_SWORD = TMP_REG2 - TMP_REG1; 
		    GPR[rd] = TMP_SWORD;
                    TMP_REG1 = GPR[rd];
                    CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		    VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD); 
		    TMP_REG1 = GPR[rd];
		    NFLAG = TMP_REG1<31..31>; 
		    if TMP_REG1 == 0 then 
		        ZFLAG = 1; 
	            else 
			 ZFLAG = 0; 
	            endif;
		   
	  	}



op SUB_imm3_thumb( imm: IMM7)
	syntax = format("sub sp, %s * 4", imm.syntax)
	image = format("101100001%s", imm.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(13);
		TMP_SWORD = TMP_REG1 - coerce(u32, imm) << 2; 
		Set_ARM_GPR(13, TMP_SWORD);
	}


op SWI_thumb(imm: IMM8)
   syntax = format("swi %s", imm.syntax)
   image = format("11011111%s",imm.image)
   action = 
	{
		//GPR[24] = NPC;
		//Uspsr[0] = Ucpsr;
		//MBITS = mode_supervisor;
		//TFLAG = 0;
		//IFLAG = 1;
		//Interruption table must be defined !
		//if (hivector == 1) then
		//	NPC = 0xFFFF0008;
		//else
		//	NPC = 0x00000008;
		//endif;
        	//"swi_impl"(imm);
	}


op TST_thumb(rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
   syntax = format("tst %s, %s",  rn.syntax, rm.syntax)
   image = format("0100001000%s%s", rm.image,  rn.image)
   action = {
	  TMP_REG2 = GPR[rn];
	  TMP_REG1 = GPR[rm];
          Temp = TMP_REG2 & TMP_REG1; 
       NFLAG = Temp<31..31>; 
       if Temp == 0 then 
	  ZFLAG = 1; 
       else 
	  ZFLAG = 0; 
       endif; 
      
	}
